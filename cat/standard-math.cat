// Dedicated to the public domain by Christopher Diggins
// This file is free to be used, modified or redistributed for any purpose,
// without restriction, obligation or warantee.
// http://www.cdiggins.com

//=============================================================================
// Dynamically dispatched functions

define neg : (any -> any)
{{
  desc:
    Negates a values.
}}
{
  [
    [neg_int] int_type
    [neg_dbl] double_type
  ] list
  dispatch1
}

define add : (any any -> any)
{
  [
    [add_int] int_type
    [add_dbl] double_type
    [add_byte] byte_type
    [add_bit] bit_type
    [add_str] string_type
  ] list
  dispatch2
}

define sub : (any any -> any)
{
  [
    [sub_int] int_type
    [sub_dbl] double_type
    [sub_byte] byte_type
    [sub_bit] bit_type
  ] list
  dispatch2
}

define mul : (any any -> any)
{
  [
    [mul_int] int_type
    [mul_dbl] double_type
    [mul_byte] byte_type
    [mul_bit] bit_type
  ] list
  dispatch2
}

define mod : (any any -> any)
{
  [
    [mod_int] int_type
    [mod_dbl] double_type
    [mod_byte] byte_type
    [mod_bit] bit_type
  ] list
  dispatch2
}

define div : (any any -> any)
{
  [
    [div_int] int_type
    [div_dbl] double_type
    [div_byte] byte_type
    [div_bit] bit_type
  ] list
  dispatch2
}

define lt : (any any -> bool)
{
  [
    [lt_int] int_type
    [lt_dbl] double_type
    [lt_byte] byte_type
    [lt_bit] bit_type
    [lt_str] string_type
  ] list
  dispatch2
  as_bool
}

define gt : (any any -> bool)
{
  [
    [gt_int] int_type
    [gt_dbl] double_type
    [gt_byte] byte_type
    [gt_bit] bit_type
    [gt_str] string_type
  ] list
  dispatch2
  as_bool
}

define lteq : (any any -> bool)
{
  [
    [lteq_int] int_type
    [lteq_dbl] double_type
    [lteq_byte] byte_type
    [lteq_bit] bit_type
    [lteq_str] string_type
  ] list
  dispatch2
  as_bool
}

define gteq : (any any -> bool)
{
  [
    [gteq_int] int_type
    [gteq_dbl] double_type
    [gteq_byte] byte_type
    [gteq_bit] bit_type
    [gteq_str] string_type
  ] list
  dispatch2
  as_bool
}

//=============================================================================
// Mathematical definitions

define sqr : (any -> any)
{{
  desc:
    Multiplies a value by itself
  test:
    in: 3 sqr
    out: 9
}}
{ dup mul }

define frac : (int int int -> int)
{{
  desc:
    Multiplies an integer by a fraction.
    x num den -> (x * num) / den)
  test:
    in: 6 2 3 frac
    out: 4
  semantics:
    $a $b $c frac == $a $b mul_int $c div_int
}}
{ [mul_int] dip div_int }

//=============================================================================
// Mathematical symbols

define + { add }
define - { sub }
define * { mul }
define % { mod }
define / { div }
define < { lt }
define > { gt }
define <= { lteq }
define >= { gteq }
define == { eq }
define != { neq }

//=============================================================================
// Predicates and comparison functions

define gtz : (int -> bool) { 0 gt_int }
define gteqz : (int -> bool) { 0 gteq_int }
define ltz : (int -> bool) { 0 lt_int }
define lteqz : (int -> bool) { 0 lteq_int }

define even : (any -> any bool) { 2 modn }
define odd : (any -> any bool) { even not }

define is_eq : ('t 't -> 't bool)  { dupd eq }
define is_neq : ('t 't -> 't bool) { dupd neq }
define is_gt : (any any -> any bool) { dupd gt }
define is_gteq : (any any -> any bool) { dupd gteq }
define is_lt : (any any -> any bool) { dupd lt }
define is_lteq : (any any -> any bool) { dupd lteq }
define is_eqz : ('t -> 't bool)  { dup 0 eq }
define is_neqz : ('t -> 't bool) { dup 0 neq }
define is_gtz : (any -> any bool) { dup 0 gt }
define is_gteqz : (any -> any bool) { dup 0 gteq }
define is_ltz : (any -> any bool) { dup 0 lt }
define is_lteqz : (any -> any bool) { dup 0 lteq }

define are_eq : ('t 't -> 't 't bool)  { dup2 eq }
define are_neq : ('t 't -> 't 't bool) { dup2 neq }
define are_gt : (any any -> any any bool) { dup2 gt }
define are_gteq : (any any -> any any bool) { dup2 gteq }
define are_lt : (any any -> any any bool) { dup2 lt }
define are_lteq : (any any -> any any bool) { dup2 lteq }

//=============================================================================
// Predicate generation functions

define ltf : (any -> (any -> bool))
{ [lt] papply }

define lteqf : (any -> (any -> bool))
{ [lteq] papply }

define gtf : (any -> (any -> bool))
{ [gt] papply }

define gteqf : (any -> (any -> bool))
{ [gteq] papply }

define eqf : ('a -> ('a -> bool))
{ [eq] papply }

define neqf : ('a -> ('a -> bool))
{ [neq] papply }

define modnf : (any -> (any -> bool))
{ [modn] papply }

//=============================================================================
// Comparison predicates

define compare_lt : (any any -> any any bool)
{ dup2 lt }

define compare_lteq : (any any -> any any bool)
{ dup2 lteq  }

define compare_gt : (any any -> any any bool)
{ dup2 gt }

define compare_gteq : (any any -> any any bool)
{ dup2 lt }

// The default comparison predicate uses lteq ( <= )
define compare : (any any -> any any bool)
{ compare_lteq }