// Dedicated to the public domain by Christopher Diggins
// This file is free to be used, modified or redistributed for any purpose,
// without restriction, obligation or warantee.
// http://www.cdiggins.com

//=============================================================================
// Dynamically dispatched functions

define neg : (any -> any)
{{
  desc:
    Negates a values.
}}
{
  [
    int_type [neg_int] pair
    double_type [neg_dbl] pair
  ] list
  dispatch1
}

define add : (any any -> any)
{
  [
    int_type [add_int] pair
    double_type [add_dbl] pair
    byte_type [add_byte] pair
    bit_type [add_bit] pair
    string_type [add_str] pair
  ] list
  dispatch2
}

define sub : (any any -> any)
{
  [
    int_type [sub_int] pair
    double_type [sub_dbl] pair
    byte_type [sub_byte] pair
    bit_type [sub_bit] pair
  ] list
  dispatch2
}

define mul : (any any -> any)
{
  [
    int_type [mul_int] pair
    double_type [mul_dbl] pair
    byte_type [mul_byte] pair
    bit_type [mul_bit] pair
  ] list
  dispatch2
}

define mod : (any any -> any)
{
  [
    int_type [mod_int] pair
    double_type [mod_dbl] pair
    byte_type [mod_byte] pair
    bit_type [mod_bit] pair
  ] list
  dispatch2
}

define div : (any any -> any)
{
  [
    int_type [div_int] pair
    double_type [div_dbl] pair
    byte_type [div_byte] pair
    bit_type [div_bit] pair
  ] list
  dispatch2
}

define lt : (any any -> bool)
{
  [
    int_type [lt_int] pair
    double_type [lt_dbl] pair
    byte_type [lt_byte] pair
    bit_type [lt_bit] pair
    string_type [lt_str] pair
  ] list
  dispatch2
  as_bool
}

define gt : (any any -> bool)
{
  [
    int_type [gt_int] pair
    double_type [gt_dbl] pair
    byte_type [gt_byte] pair
    bit_type [gt_bit] pair
    string_type [gt_str] pair
  ] list
  dispatch2
  as_bool
}

define lteq : (any any -> bool)
{
  [
    int_type [lteq_int] pair
    double_type [lteq_dbl] pair
    byte_type [lteq_byte] pair
    bit_type [lteq_bit] pair
    string_type [lteq_str] pair
  ] list
  dispatch2
  as_bool
}

define gteq : (any any -> bool)
{
  [
    int_type [gteq_int] pair
    double_type [gteq_dbl] pair
    byte_type [gteq_byte] pair
    bit_type [gteq_bit] pair
    string_type [gteq_str] pair
  ] list
  dispatch2
  as_bool
}

//=============================================================================
// Mathematical definitions

define sqr : (any -> any)
{{
  desc:
    Multiplies a value by itself
  test:
    in: 3 sqr
    out: 9
}}
{ dup mul }

define frac : (int int int -> int)
{{
  desc:
    Multiplies an integer by a fraction.
    x num den -> (x * num) / den)
  test:
    in: 6 2 3 frac
    out: 4
  semantics:
    $a $b $c frac == $a $b mul_int $c div_int
}}
{ [mul_int] dip div_int }

//=============================================================================
// Mathematical symbols

define + { add }
define - { sub }
define * { mul }
define % { mod }
define / { div }
define < { lt }
define > { gt }
define <= { lteq }
define >= { gteq }
define == { eq }
define != { neq }

//=============================================================================
// Predicates and comparison functions

define eqz : (int -> int bool)  { dup 0 eq }
define neqz : (int -> int bool) { eqz not }
define gtz : (int -> int bool) { dup 0 gt_int }
define gteqz : (int -> int bool) { dup 0 gteq_int }
define ltz : (int -> int bool) { dup 0 lt_int }
define lteqz : (int -> int bool) { dup 0 lteq_int }

// Not really a predicate, but used to generate predicates
define modn : (any any -> any bool) { dupd mod 0 eq }

define even : (any -> any bool) { 2 modn }
define odd : (any -> any bool) { even not }

define is_eq : ('t 't -> 't bool)  { dupd eq }
define is_neq : ('t 't -> 't bool) { dupd neq }
define is_gt : (any any -> any bool) { dupd gt }
define is_gteq : (any any -> any bool) { dupd gteq }
define is_lt : (any any -> any bool) { dupd lt }
define is_lteq : (any any -> any bool) { dupd lteq }

define are_eq : ('t 't -> 't 't bool)  { dup2 eq }
define are_neq : ('t 't -> 't 't bool) { dup2 neq }
define are_gt : (any any -> any any bool) { dup2 gt }
define are_gteq : (any any -> any any bool) { dup2 gteq }
define are_lt : (any any -> any any bool) { dup2 lt }
define are_lteq : (any any -> any any bool) { dup2 lteq }

//=============================================================================
// Predicate generation functions

define ltf : (any -> (any -> bool))
{ [lt] papply }

define lteqf : (any -> (any -> bool))
{ [lteq] papply }

define gtf : (any -> (any -> bool))
{ [gt] papply }

define gteqf : (any -> (any -> bool))
{ [gteq] papply }

define eqf : ('a -> ('a -> bool))
{ [eq] papply }

define neqf : ('a -> ('a -> bool))
{ [neq] papply }

define modnf : (any -> (any -> bool))
{ [modn] papply }

//=============================================================================
// Comparison predicates

define compare_lt : (any any -> any any bool)
{ dup2 lt }

define compare_lteq : (any any -> any any bool)
{ dup2 lteq  }

define compare_gt : (any any -> any any bool)
{ dup2 gt }

define compare_gteq : (any any -> any any bool)
{ dup2 lt }

// The default comparison predicate uses lteq ( <= )
define compare : (any any -> any any bool)
{ compare_lteq }