/*
  filename: parsing.cat
  author: Christopher Diggins
  license: Public Domain
  url: http://www.cat-language.com
  desc:
    this is a combinator parsing library for recursive
    descent parsing of parsing expression grammars (PEGs)
*/

"standard.cat" #load

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Parsing combinator library functions

define p_tok : (list any -> list bool)
{{
  desc:
    Matches a single token on the input stream.
  test:
    in: [1 2 3] @ 1 p_tok
    out: [1 2 3] @ false
  test:
    in: [1 2 3] @ 3 p_tok
    out: [1 2] @ true
}}
{ head_eq [tail true] [false] if }

define p_star : ('A ('A -> 'A bool) -> 'A bool)
{{
  desc:
    Matches a parse rule against input repeatedly until it fails,
    and will always return true.
  test:
    in: [0 1 0 1 1 1] @ [1 p_tok] p_star
    out: [0 1 0] @ true
  test:
    in: [0 1 0] @ [1 p_tok] p_star
    out: [0 1 0] @ true
  test:
    in: [0 1 0] @ [0 p_tok] p_star
    out: [0 1] @ true
}}
{ true swap [kapply] [swap] while true popd }

define p_opt : ('A ('A -> 'A 'b) -> 'A bool)
{{
  desc:
    Matches a parse rule against input, returning true whether
    or not it was successful
  test:
    in: [0 1] @ [1 p_tok] p_opt
    out: [0] @ true
  test:
    in: [0 1] @ [0 p_tok] p_opt
    out: [0 1] @ true
}}
{ apply pop true }

define p_plus : ('A ('A -> 'A bool) -> 'A bool)
{{
  desc:
    Matches a parse rule against input repeatedly until it fails.
    Returns true if it succeeds at least once.
  test:
    in: [0 1 1] @ [1 p_tok] p_plus
    out: [0] @ true
  test:
    in: [0 1 1] @ [0 p_tok] p_plus
    out: [0 1 1] @ false
}}
{ kapply swap [p_star] [pop false] if }

define p_at : ('A 'b ('A 'b 'b -> 'B 'c 'd bool) -> 'B 'd bool)
{{
  desc:
    Returns true if the parse rule will return true if matched.
    Does not advance the input
  test:
    in: [0 1] @ [1 p_tok] p_at
    out: [0 1] @ true
  test:
    in: [0 1] @ [0 p_tok] p_at
    out: [0 1] @ false
}}
{ dupd apply popd }

define p_not : (list ('A -> list bool) -> list bool)
{{
  desc:
    Returns true if the parse rule will fail if matched.
    Does not advance the input.
  test:
    in: [0 1] @ [1 p_tok] p_not
    out: [0 1] @ false
  test:
    in: [0 1] @ [0 p_tok] p_not
    out: [0 1] @ true
}}
{ p_at not }

define p_end : (list -> list bool)
{{
  desc:
    returns true if there is no more input to be parsed
  test:
    in: [0 1] @ p_end
    out: [0 1] @ false
  test:
    in: [] @ p_end
    out: [] @ true
}}
{ empty }

define p_or : ('A list ('A list -> 'A list bool) -> 'B bool)
{{
  desc:
    Applies a list of parsing rules in order, until one succeeds, at which
    point it returns true, otherwise it returns false.
  test:
    in: [0 1] @ [[0 p_tok] [1 p_tok]] @ p_or
    out: [0] @ true
  test:
    in: [0 1] @ [[0 p_tok] [2 p_tok]] @ p_or
    out: [0 1] @ false
}}
{ false [uncons dip] [empty not] while }

define p_seq : ('A ('A -> 'A bool) -> 'B bool)
{{
  desc:
    Applies a list of parsing rules in sequence, returning true if it succeeds
    or returning false and restoring the input if it fails.
  test:
    in: [2 0 1] @ [[1 p_tok] [0 p_tok]] @ p_seq
    out: [2] @ true
  test:
    in: [2 0 1] @ [[1 p_tok] [1 p_tok]] @ p_seq
    out: [2 0 1] @ false
}}
{ true [uncons dip] [[empty not] dip and] while popd }

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// abstract syntax tree building code

define start_ast_node : (list list -> list list)
{{
  desc:
    Add a new node to the abstract syntax tree.
}}
{ [unit cons] keep }

define complete_ast_node : (list list -> list list)
{{
  desc:
    Updates the most recent node with the current input state.
}}
{ [[uncons] dip cons cons] keep }

define abandon_ast_node : (list list -> list list)
{{
  desc:
    Deletes the most recently created node.
}}
{ [uncons tail cons] dip }

define p_ast : (list list (list -> list bool) -> list list bool)
{{
  desc:
    Matches a parse rule, and if successful adds a node to the tree.
}}
{
  [start_ast_node] dip apply
    [complete_ast_node true]
    [abandon_ast_node false]
  if
}

//

define instruction {
  
  hash_set
}

define exec_instruction {
  switch
}

define parse_cat_program {
  ast
  input
  [
    uncons
    [parse_quotation] ['['] eq
    [parse_name] [is_name] cond
    apply
  ]
  whilene
}