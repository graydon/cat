//============================================================================
// Sorting functions

define ordered_swap : ('a 'a -> 'a 'a)
{ compare [] [swap] if }

define sorted_insert : (list 'a -> list)
{ nil [uncons] dip [swapd swap cons] [[empty not] dip] while cat }

define insert_sort
{
  "not completed yet" throw
}

define test_list : ( -> list)
{
  ((1, "a"),(2, "b"),(3, "a"),(4, "c"),(5, "b"),(6, "a"))
}

define list_to_hash_test
{ test_list self_join }

define if_swap : ('a 'a  ('a 'a -> 'a 'a bool) -> 'a 'a)
{ eval [] [swap] if }

define test_strings
{
  (
    (("The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog"), 1),
    (("I", "am", "very", "lazy"), 2),
    (("I", "hope", "this", "is", "over", "quick"), 3),
    (("I", "have", "high", "hopes", "for", "the", "lazy", "dog"), 4)
  )
}
define test_m
{ unpair pop [1 swap pair] map }

define test_r
{ unpair [sum] dip pair }

define test_map_reduce
{ test_strings [test_m] [test_r] map_reduce print_list }

define girard (n x) {
  x n pow 1 neg n pow *
}

define gunfold : ('A 'b ('A list 'b -> 'A list) ('A list 'b -> 'A list 'b bool) -> 'A list)
{{
  desc:
    Generates a list by applying a successor functions, until the predicate is true.
    This is a generalized version of the unfold function.
  alt:
    define gunfold(init, succ, term) { nil init [succ] [term not] while }
  test:
    in: 1 [dup inc swap] [dup 5 gt] gunfold
    out: [1 2 3 4 5]
}}
{ [nil bury [consd compose] dip whilen pop }
