


map (k1,v1) ! list(k2,v2)
  ->
reduce (k2,list(v2)) ! list(v2)
  ->

define map_reduce :
(
  input=list(record('key, 'value))
  mapf=(record('key, 'value) -> tmp=list(record('key2, 'value2))
  reducef=(record('key2, list('value2) -> list('value2)
)
{
  [map] swip           // input [mapf] [reducef] => tmp [reducef]

  [reduce] curry       // => list(record('key2, list('value2))) [[reducef] reduce]
  map                  // => list('key2, list('value2))
}

define map_reduce { [map] swip [reduce] curry map }


define map_reduce(input mapf reducef) { input mapf [reducef reduce] map }


define map_reduce(x m r) { x m map [r reduce] map }

map(String key, String value):
  // key: document name
  // value: document contents
  for each word w in value:
    EmitIntermediate(w, "1");

reduce(String key, Iterator values):
  // key: a word
  // values: a list of counts
  int result = 0;
  for each v in values:
    result += ParseInt(v);
  Emit(AsString(result));


hash_list : ( -> hash_list)
hash_cons : (hash_list var list -> hash_list)
hash_get : (hash_list var -> hash_list list)
hash_keys : (hash_list -> hash_list list)
hash_values : (hash_list -> hash_list list)

list_to_hash : ...

hash_lists == lists. Notice I want to do things like reduce.

hash_contains (hash_list var -> hash_list var bool)

// Adds an element as unit list to a hash_list if it doesn't exist,
// otherwise chains it to the current list item.
define hash_add_chain : (hash_list var -> hash_list)
{ hash_contains [hash_get swons] [unit] if hash_set }


