// Widefinder Demo in Cat
// http://erikengbrecht.blogspot.com/2007/11/adventures-in-widefinding.html
// http://www.tbray.org/ongoing/When/200x/2007/09/29/WF-Goal

/*
Implementation in Ruby
Problem: sequential

  counts = {}
  counts.default = 0

  ARGF.each_line do |line|
    if line =~ %r{GET /ongoing/When/\d\d\dx/(\d\d\d\d/\d\d/\d\d/[^ .]+) }
      counts[$1] += 1
    end
  end

  keys_by_count = counts.keys.sort { |a, b| counts[b] <=> counts[a] }
  keys_by_count[0 .. 9].each do |key|
    puts "#{counts[key]}: #{key}"
  end
*/

define wide_finder
{
  open

  // The map step: generating value, key pairs from an input datum
  [
    "GET /ongoing/When/\d\d\dx/(\d\d\d\d/\d\d/\d\d/[^ .]+) " match
    empty
    [ ] // leave the empty list
    [ first 1 swap pair ] // make a "value, key" pair
    if
  ]

  // The filter step: remove empty data
  [ empty not ]

  // The merge step: how data with the same key is dealt with
  [ second swap unpair ]

  file_filter_map_reduce

  // Sort by the count
  [[cadr] app2 <=] sort

  // Take the first 10 items
  10 take_n

  // Write each pair
  [writeln] foreach
}

