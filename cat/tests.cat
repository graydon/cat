define test : (('a -> 'b) list -> bool)
{
  [list] dip
  compare_lists
}


define test_list : ( -> list)
{
  ((1, "a"),(2, "b"),(3, "a"),(4, "c"),(5, "b"),(6, "a"))
}

define list_to_hash_test
{ test_list self_join }


// This is essentially a non-distributed naive implementation of the google MapReduce algorithm
//
// In pseduo-code:
//
//   map_reduce(input fmap freduce) == input fmap flatten self_join freduce map
//
// where:
//
//     input = list(pair('input_value, 'input_key))
//     fmap = pair('input_value, 'input_key)) -> list(pair('output_value, 'output_key))
//     freduce = pair(list('output_value), 'output_key) -> pair('output_value, 'output_key)
//
define map_reduce { [map flatten self_join] dip map }

define test_strings
{
  (
    (("The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog"), 1),
    (("I", "am", "very", "lazy"), 2),
    (("I", "hope", "this", "is", "over", "quick"), 3),
    (("I", "have", "high", "hopes", "for", "the", "lazy", "dog"), 4)
  )
}
define test_m
{ unpair pop [1 swap pair] map }

define test_r
{ unpair [sum] dip pair }

define test_map_reduce
{ test_strings [test_m] [test_r] map_reduce print_list }

define if_swap : ('a 'a  ('a 'a -> 'a 'a bool) -> 'a 'a)
{ eval [] [swap] if }

//============================================================================
// Sorting functions

define ordered_swap : ('a 'a -> 'a 'a)
{ compare [] [swap] if }

define sorted_insert : (list 'a -> list)
{ nil [uncons] dip [swapd swap cons] [[empty not] dip] while cat }

define insert_sort
{ }



