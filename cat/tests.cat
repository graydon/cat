// Cat Standard Tests
// by Christopher Diggins
// http://www.cdiggins.com
// this file is public domain
//
// These tests are ordered in terms of increasing sophistiction of a Cat implementation
// simpler implementations would not be expected to support the whole range.

define test : (( -> bool) -> )
{
  dup eval [pop] [throw] if
}

// This is designed to test a minimalist Cat implementation
define test0
{
  // if tests
  [true [true] [false] if] test
  [false [false] [true] if] test
  [false [true] [false] if not] test
  [true [false] [true] if not] test

  // boolean tests
  [true] test
  [true not not] test
  [false not] test
  [false not not not] test

  // and tests
  [true true and] test
  [true false and not] test
  [false true and not] test
  [false false and not] test

  // or tests
  [true true or] test
  [true false or] test
  [false true or] test
  [false false or not] test

  // basic equality tests
  [0 0 eq] test
  [1 1 eq] test
  [0 1 eq not] test
  [1 0 eq not] test

  // basic comparison tests
  [0 0 lteq] test
  [0 1 lteq] test
  [1 0 lteq not] test
  [1 1 lteq] test

  // swap tests
  [1 2 pop 1 eq] test
  [1 2 swap pop 2 eq] test
  [1 2 swap swap pop 1 eq] test

  // dip tests
  [1 1 2 [eq] dip pop] test
  [1 2 1 [neq] dip pop] test
  [2 [1] dip pop 1 eq] test
  [1 [2] dip pop 2 eq] test
  [2 1 [pop] dip 1 eq] test
  [1 2 [pop] dip 2 eq] test
  [1 2 3 [swap] dip pop pop 2 eq] test
  [1 2 3 [pop] dip pop 1 eq] test
  [1 2 3 [pop pop] dip 3 eq] test
  [1 2 3 [[pop] dip pop] dip 3 eq] test
  [1 2 3 [[pop] dip] dip swap pop 3 eq] test
}

define _43210
{ 0 [1 add] [5 lt] gen }

define _3210
{ 0 4 [id] range_gen }

define _234
{ [2 3 4] to_list }

define _01234
{ [0 1 2 3 4] to_list }

define _23
{ 2 3 pair }

define _012
{ nil 0 cons 1 cons 2 cons }

define _01
{ 0 1 pair }

define _0
{ 0 unit }

define _0123
{ _01 _23 cat }

define test1
{
  // comparison tests
  [0 0 lteq] test
  [0 0 gteq] test
  [0 1 lt] test
  [0 1 lteq] test
  [0 1 gt not] test
  [0 1 gteq not] test
  [1 0 lt not] test
  [1 0 lteq not] test
  [1 0 gt] test
  [1 0 gteq] test
  [1 1 lt not] test
  [1 1 lteq] test
  [1 1 gt not] test
  [1 1 gteq] test

  // core equality tests
  [nil nil eq] test
  [_0 _0 eq] test
  [_01 _01 eq] test
  [_012 _012 eq] test
  [_0123 _0123 eq] test

  // to_list generator
  [[0] to_list _0 eq] test
  [[0 1] to_list _01 eq] test
  [[0 1 2] to_list _012 eq] test
  [[0 1 2 3] to_list _0123 eq] test

  // cons
  [nil 1 cons 1 unit eq] test

  // head items
  [_0 head 0 eq] test
  [_01 head 1 eq] test
  [_012 head 2 eq] test
  [_0123 head 3 eq] test
  [_01234 head 4 eq] test
  [_43210 head 0 eq] test
  [_3210 head 0 eq] test
  [_234 head 4 eq] test
  [_23 head 3 eq] test

  // first=head
  [_0 first swap head eq] test
  [_01 first swap head eq] test
  [_012 first swap head eq] test
  [_0123 first swap head eq] test
  [_01234 first swap head eq] test
  [_43210 first swap head eq] test
  [_3210 first swap head eq] test
  [_234 first swap head eq] test
  [_23 first swap head eq] test

  // last items
  [_0 last swap pop 0 eq] test
  [_01 last swap pop 0 eq] test
  [_012 last swap pop 0 eq] test
  [_0123 last swap pop 0 eq] test
  [_01234 last swap pop 0 eq] test
  [_43210 last swap pop 4 eq] test
  [_3210 last swap pop 3 eq] test
  [_234 last swap pop 2 eq] test
  [_23 last swap pop 2 eq] test

  // to_list to non-list comparison
  [nil 0 neq] test
  [0 nil neq] test

  // empty
  [nil empty swap pop] test
  [_0123 empty swap pop not] test
  [_012 empty swap pop not] test
  [_01 empty swap pop not] test
  [_0 empty swap pop not] test

  // count
  [_0123 count swap pop 4 eq] test
  [_012 count swap pop 3 eq] test
  [_01 count swap pop 2 eq] test
  [_0 count swap pop 1 eq] test
  [nil count swap pop 0 eq] test

  // cat
  [_01 _23 cat _0123 eq] test
  [0 unit 1 unit cat _01 eq] test

  // nth test
  [_0123 0 nth swap pop 3 eq] test
  [_0123 1 nth swap pop 2 eq] test
  [_0123 2 nth swap pop 1 eq] test
  [_0123 3 nth swap pop 0 eq] test
  [_012 0 nth swap pop 2 eq] test
  [_012 1 nth swap pop 1 eq] test
  [_012 2 nth swap pop 0 eq] test
  [_01 0 nth swap pop 1 eq] test
  [_01 1 nth swap pop 0 eq] test
  [_0 0 nth swap pop 0 eq] test

  // map test
  [_0123 [2 *] map [0 2 4 6] to_list eq] test
  [_012 [2 *] map [0 2 4] to_list eq] test
  [_01 [2 *] map [0 2] to_list eq] test
  [_0 [2 *] map [0] to_list eq] test
  [nil [2 *] map nil eq] test
  [_0123 [1 +] map [1 2 3 4] to_list eq] test
  [_012 [1 +] map [1 2 3] to_list eq] test
  [_01 [1 +] map [1 2] to_list eq] test
  [_0 [1 +] map [1] to_list eq] test
  [nil [1 +] map nil eq] test

  // filter
  [_0123 [1 gt] filter [2 3] to_list eq] test
  [_012 [1 gt] filter [2] to_list eq] test
  [_01 [1 gt] filter nil eq] test
  [_0 [1 gt] filter nil eq] test
  [nil [1 gt] filter nil eq] test
  [_0123 [2 lt] filter _01 eq] test
  [_012 [2 lt] filter _01 eq] test
  [_01 [2 lt] filter _01 eq] test
  [_0 [2 lt] filter _0 eq] test
  [nil [2 lt] filter nil eq] test
  [_0123 [2 mod 0 eq] filter [0 2] to_list eq] test
  [_012 [2 mod 0 eq] filter [0 2] to_list eq] test
  [_01 [2 mod 0 eq] filter _0 eq] test
  [_0 [2 mod 0 eq] filter _0 eq] test
  [nil [2 mod 0 eq] filter nil eq] test

  // fold
  [_0123 0 [+] fold 6 eq] test
  [_012 0 [+] fold 3 eq] test
  [_01 0 [+] fold 1 eq] test
  [_0 0 [+] fold 0 eq] test
  [nil 0 [+] fold 0 eq] test
  [_0123 nil [cons] fold [3 2 1 0] to_list eq] test

  // take
  [_01234 0 take nil eq] test
  [_0123 0 take nil eq] test
  [_012 0 take nil eq] test
  [_01 0 take nil eq] test
  [_0 0 take nil eq] test
  [nil 0 take nil eq] test
  [_01234 1 take 4 unit eq] test
  [_0123 1 take 3 unit eq] test
  [_012 1 take 2 unit eq] test
  [_01 1 take 1 unit eq] test
  [_0 1 take _0 eq] test
  [nil 1 take nil eq] test
  [_01234 5 take _01234 eq] test
  [_0123 5 take _0123 eq] test
  [_012 5 take _012 eq] test
  [_01 5 take _01 eq] test
  [_0 5 take _0 eq] test
  [nil 5 take nil eq] test

  // drop
  [_01234 0 drop _01234 eq] test
  [_0123 0 drop _0123 eq] test
  [_012 0 drop _012 eq] test
  [_01 0 drop _01 eq] test
  [_0 0 drop _0 eq] test
  [nil 0 drop nil eq] test
  [_01234 5 drop nil eq] test
  [_0123 5 drop nil eq] test
  [_012 5 drop nil eq] test
  [_01 5 drop nil eq] test
  [_0 5 drop nil eq] test
  [nil 5 drop nil eq] test
  [_01234 1 drop _0123 eq] test
  [_0123 1 drop _012 eq] test
  [_012 1 drop _01 eq] test
  [_01 1 drop _0 eq] test
  [_0 1 drop nil eq] test
  [nil 1 drop nil eq] test

  // tail
  [_01234 tail _0123 eq] test
  [_0123 tail _012 eq] test
  [_012 tail _01 eq] test
  [_01 tail _0 eq] test
  [_0 tail nil eq] test
  [nil tail nil eq] test

  // take while
  [[1 0 3 2 1 0] to_list [2 lt] take_while [1 0] to_list eq] test

  // drop while
  [[1 0 3 2 1 0] to_list [2 lt] drop_while [1 0 3 2] to_list eq] test
}

define test_strings
{
  (
    (("The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog"), 1),
    (("I", "am", "very", "lazy"), 2),
    (("I", "hope", "this", "is", "over", "quick"), 3),
    (("I", "have", "high", "hopes", "for", "the", "lazy", "dog"), 4)
  )
}

define test_pair_list : ( -> list)
{
  ((1, "a"),(2, "b"),(3, "a"),(4, "c"),(5, "b"),(6, "a"))
}

define test_joined_list : ( -> list)
{
  (
    ((4), "c"),
    ((5, 2), "b"),
    ((6, 3, 1), "a")
  )
}

define test_m
{ unpair pop [1 swap pair] map }

define test_r
{ unpair [sum] dip pair }

define test_map_reduce
{ test_strings [test_m] [test_r] map_reduce print_list }

define test2
{
  [() nil eq] test

  // flatten tests
  [(()) flatten nil eq] test
  [((0)) flatten (0) eq] test
  [((0),(1)) flatten (0,1) eq] test
  [((0),((1))) flatten (0,(1)) eq] test
  [((0,1),(2,3),(4),nil,(5,6,7)) flatten (0,1,2,3,4,5,6,7) eq] test

  // pair tests
  [1 2 pair [1 2] to_list eq] test
  [1 2 pair (1, 2) eq] test
  [[1 2] to_list (1, 2) eq] test
  [(1, 2) unpair pair (1, 2) eq] test
  [(1, (2,3)) unpair swap pop (2, 3) eq] test

  // Hash to_list tests
  [hash_list hash_to_list nil eq] test
  [hash_list "a" 1 hash_add hash_to_list ((1, "a")) eq] test
  [hash_list 1 hash_contains swap pop not] test
  [hash_list "hello" hash_contains swap pop not] test
  [hash_list "a" 1 hash_add "a" hash_contains swap pop] test
  [hash_list "a" 1 hash_add "b" hash_contains swap pop not] test
  [hash_list 24 "a" hash_add 24 hash_get swap pop "a" eq] test
  [hash_list "a" 42 hash_add "a" hash_get swap pop 42 eq] test
  [test_pair_list self_join test_joined_list eq] test

  // pair to_list tests
  [nil nil pair ((),()) eq] test
  [nil nil pair 1 cons_first (nil,(1)) eq] test
  [nil nil pair 1 cons_second ((1),nil) eq] test

  // gfold test (gets the 8th fibonnaci number)
  [0 1 6 n [pop dup2 + dig pop] gfold + 21 eq] test

  // split tests
  [(1, 2) [2 <] split pair ((1),(2)) eq] test
  [(1, 2) [2 >] split pair ((),(2, 1)) eq] test
  [(1, 2) [1 >] split pair ((2),(1)) eq] test
  [(1, 2) [pop true] split pair ((2, 1),()) eq] test
  [(1, 2) [pop false] split pair ((),(2, 1)) eq] test
  [() [true] split pair ((),()) eq] test

  // small tests
  [() small nip] test
  [(0) small nip] test
  [(0,1) small nip not] test
}

define test3
{
  [0 0 range nil eq] test
  [0 1 range (0) eq] test
  [0 2 range (1, 0) eq] test
  [0 3 range (2, 1, 0) eq] test
  [0 4 range (3, 2, 1, 0) eq] test
  [0 5 range (4, 3, 2, 1, 0) eq] test
  [1 1 range (1) eq] test
  [1 2 range (2, 1) eq] test
  [1 3 range (3, 2, 1) eq] test
  [1 4 range (4, 3, 2, 1) eq] test
  [1 5 range (5, 4, 3, 2, 1) eq] test
  [2 1 range (2) eq] test
  [2 2 range (3, 2) eq] test
  [2 3 range (4, 3, 2) eq] test
  [2 4 range (5, 4, 3, 2) eq] test
  [2 5 range (6, 5, 4, 3, 2) eq] test
}

define test4
{
  [5 n head 0 eq] test
  [5 n tail 1 4 range eq] test
  [5 n count swap pop 5 eq] test
  [5 n [pop true] count_while swap pop 5 eq] test
  [5 n empty swap pop not] test
  [5 n (4, 3, 2, 1, 0) eq] test
  [5 n [4 3 2 1 0] to_list eq] test
  [5 n 0 5 range eq] test
  [5 n 0 5 [inc dec] range_gen eq] test
  [5 n 0 [inc] [5 <] gen eq] test
  [5 n naturals 5 take eq] test
  [5 n naturals [5 <] take_while eq] test
  [5 n [3 <] take_while 3 n eq] test
  [5 n 3 take 3 n eq] test
  [5 n naturals [5 <] [] lc eq] test
}

// floating point comparisons
define test5
{
  [1.0 2.0 <=] test
  [1 2.0 <=] test
  [1.0 2 <=] test
  [2.0 1.0 >=] test
  [2 1.0 >=] test
  [2.0 1 >=] test
  [1.0 1.0 + 1.0 1.0 + eq] test
}

// Test numerical representations
define test6
{
  [0b1 1 eq] test
  [0b0 0 eq] test
  [0b1001 9 eq] test
  [0b10000000000 1024 eq] test
  [0x1 1 eq] test
  [0x0 0 eq] test
  [0xff 255 eq] test
  [0x100 256 eq] test
  [0b100000000 256 eq] test
  [255 str "255" eq] test
  [255 hex_str "ff" eq] test
  [255 bin_str "11111111" eq] test
  [0x234 byte 0x34 byte eq] test
}

define test7
{
  [4 [eqz] [pop 1] [dec dup] [+] bin_rec 16 eq] test

  // test qsort
  [() qsort () eq] test
  [(1) qsort (1) eq] test
  [(4,2,3,1) qsort (1,2,3,4) eq] test
  [(1,2,3,4) qsort (1,2,3,4) eq] test
  [(4,3,2,1) qsort (1,2,3,4) eq] test
  [(1,1,1,1) qsort (1,1,1,1) eq] test
  [(2,4,3,2,1,1,3,4) qsort (1,1,2,2,3,3,4,4) eq] test

  // test byte blocks
  [0 byte_block count nip 0 eq] test
  [1 byte_block count nip 1 eq] test
  [99 byte_block count nip 99 eq] test
  [42 byte_block 13 nth nip 0 byte eq] test
  [42 byte_block 25 byte 13 set_at 13 nth nip 25 byte eq] test

  // Note: I would have expected the following line to work
  // [4 byte_block 12 byte 1 set_at 30 byte 2 set_at sum 42 byte eq] test
  // but it doesn't. For some reason integer addition is being chosen over
  // byte addition. This is a bug that I will have to fix later on.
  [4 byte_block 12 byte 1 set_at 30 byte 2 set_at sum 42 eq] test
}

define test_io
{
  temp_file dup
  file_writer
  2 byte_block
  0xf1 byte 0 set_at
  0xa9 byte 1 set_at
  write_bytes
  close_stream
  file_reader
  2 read_bytes
  [close_stream] dip
}

define test_types
{
  [] #t
  [id] #t
  [id id] #t
  [id id id] #t
  [dup] #t
  [dup dup] #t
  [dup dup dup] #t
  [pop] #t
  [pop pop] #t
  [pop pop pop] #t
  [swap] #t
  [swap swap] #t
  [swap swap swap] #t
  [swap pop] #t
  [pop swap] #t
  [swap dup] #t
  [dup swap] #t
  [swap pop dup] #t
  [swap dup pop] #t
  [dup swap pop] #t
  [pop swap dup] #t
  [pop dup swap] #t
  [dup pop swap] #t
  [eval] #t
  [eval eval] #t
  [eval eval eval] #t
  [dup dip] #t
  [dup eval] #t
  [dip dip] #t
  [dip dup] #t
}

define run_tests
{
  test0
  test1
  test2
  test3
  test4
  test5
  test6
  test7
  "tests completed successfully" writeln
}
