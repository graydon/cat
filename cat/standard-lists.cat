// Dedicated to the public domain by Christopher Diggins
// This file is free to be used, modified or redistributed for any purpose,
// without restriction, obligation or warantee.
// http://www.cdiggins.com

define (
{{
  desc:
    List initializer.
  tests:
    in: nil
    out: [] list
}}
{ nil }

define ,
{{
  desc:
    List separator.
}}
{ cons }

define )
{{
  desc:
    List terminator.
}}
{ cons }

define ()
{{
  desc:
    Empty list.
}}
{ nil }

define consd
{{
  desc:
    Append the second item on stack to a list in the third position.
  tests:
    in: [1 2] list 3 4 consd
    out: [1 2 3] list 4
}}
{ [cons] dip }

define swons : ('a list -> list)
{{
  desc:
    Appends the second item on the stack, to a list in the first item
  tests:
    in: 3 [1 2] list swons
    out: [1 2 3] list
}}
{ swap cons }

define uncons2 : (list -> list any any)
{{
  desc:
    Extracts the first and second item from a list
  tests:
    in: [1 2 3] list uncons2
    out: [1] list 2 3
}}
{ uncons [uncons] dip }

define unpair : (list -> any any)
{{
  desc:
    Extracts the first and second item from a list
  tests:
    in: [1 2] list unpair
    out: 1 2
}}
{ uncons [head] dip }

define gunfold : ('A 'b ('A list 'b -> 'A list 'c 'b) ('A list 'b -> 'A list 'b bool) -> 'A list)
{{
  desc:
    Generates a list by applying a successor functions, until the predicate is true.
    This is a generalized version of the unfold function.
  tests:
    in: 1 [dup inc swap] [dup 5 lteq]
}}
{ [nil bury [consd] compose] dip whilen pop }

define rev : (list -> list)
{{
  desc:
    Reverses a list
  tests:
    in: [1 2 3] list rev
    out: [1 2 3]
}}
{ nil [cons] fold }

define small : (list -> list bool)
{{
  desc:
    Returns true if a list contains one element or is empty
  tests:
    in: 1 unit small popd
    out: true
}}
{ empty [true] [rest empty popd] if }

define split : ('A list ('b -> bool) -> 'A list list)
{{
  desc:
    Splits a list into two new lists
  tests:
    in: [0 1 2 3 4] list [even] split
    out: [1 3] list [0 2 4] list
}}
{
  dup2 filter
  [negate filter] dip
}

define cons_first : (list 'a -> list)
{{
  desc:
    Appends item to first list in a pair of lists
  tests:
    in: [1 2] list [3 4] list pair 5 cons_first
    out: [1 2 5] list [3 4] list pair
}}
{ [unpair] dip cons pair }

define cons_second : (list 'a -> list)
{{
  desc
    Appends item to second list in a pair of lists
  tests:
    in: [1 2] list [3 4] list pair 5 cons_second
    out: [1 2] list [3 4 5] list pair
}}
{ [unpair] dip swap [cons] dip pair }

define move_head : (list list -> list list)
{{
  desc:
    Copies the head from one list to another.
  tests:
    in: [1 2] list [3 4] list move_head
    out: [1 2 3] list [3] list
}}
{ uncons swap [cons] dip }

define index_of : (list 'a -> list int)
{{
  desc:
    Returns the index of a value in a list or the size of the list
    if not found.
  tests:
    in: [1 2 3 4] list 1 index_of popd
    out: 3
  tests:
    in: ['a' 'b' 'c'] list 'c' index_of popd
    out: 0
  tests:
    in: ['a' 'b' 'c'] list 'd' index_of popd
    out: 3
}}
{ [neq] papply count_while }

define split_at : (list int -> list list)
{{
  desc:
    Splits a list in two at an index, the top result contains the second half
    sand the second result contains the first half of the original list
}}
{ nil bury [move_head] swap repeat }

define dhead : (list -> list any)
{{
  desc:
    Returns the head of a list, leaving the original list on the stack.
  tests:
    in: [1 2] list dhead
    out: [1 2] list 2
}}
{ first }

define dtail : (list -> list list)
{{
  desc:
    Returns the tail of a list, leaving the original list on the stack.
  tests:
    in: [1 2 3] list dtail
    out: [1 2 3] list [1 2] list
}}
{ rest }

define head_eq : (list any -> list bool)
{{
  tests:
    in: [1 2] list 2 head_eq popd
    out: true

  tests:
    in: [1 2] list 1 head_eq popd
    out: false
}}
{ [dhead] dip eq }

//=============================================================================
// Infinite list generators

define range : (int int -> list)
{{
  desc:
    Returns a list of x non-negative integers from n.
  test:
    in: 3 5 range
    out: [7 6 5 4 3] list
}}
{ [] range_gen }

define n : (int -> list)
{{
  desc:
    Returns a list of the first n non-negative integers.
  test:
    in: 4 n
    out: [3 2 1 0] list
  test:
    in: 0 n
    out: nil
}}
{ 0 swap range }

define naturals : ( -> list)
{{
  desc:
    Returns a lazy list of all the non-negative integers
}}
{ 0 [inc] [pop true] unfold }

define odds : ( -> list)
{{
  desc:
    Returns a lazy list of all the odd numbers
}}
{ 1 [2 +] [pop true] unfold }

define evens : ( -> list)
{{
  desc:
    Returns a lazy list of all the even numbers
}}
{ 0 [2 +] [pop true] unfold  }

define negatives : ( -> list)
{{
  desc:
    Returns a lazy list of all the negative numbers starting at -1
}}
{ 1 neg [dec] [pop true] unfold }

define zeros : ( -> list)
{{
  desc:
    Returns an infinite lazy list of zeros
}}
{ 0 repeater }

define ones : ( -> list)
{{
  desc:
    Returns an infinite lazy list of ones
}}
{ 1 repeater }