// Dedicated to the public domain by Christopher Diggins
// This file is free to be used, modified or redistributed for any purpose,
// without restriction, obligation or warantee.
// http://www.cdiggins.com

define (
{{
  desc:
    List initializer.
  test:
    in: nil
    out: [] list
}}
{ nil }

define ,
{{
  desc:
    List separator.
}}
{ cons }

define )
{{
  desc:
    List terminator.
}}
{ cons }

define ()
{{
  desc:
    Empty list.
}}
{ nil }

define consd
{{
  desc:
    Cons the second item on stack to a list in the third position.
}}
{ [cons] dip }

define swons : ('a list -> list)
{ swap cons }

define uncons2 : (list -> list any any)
{ uncons [uncons] dip }

define uncons3 : (list -> list any any any)
{ uncons [uncons2] dip }

define uncons4 : (list -> list any any any any)
{ uncons [uncons3] dip }

define unpair : (list -> any any)
{ uncons [head] dip }

define fold : ('A list 'b ('A 'b 'c -> 'A 'b) -> 'A 'b)
{ swapd gfold }

define unfold : ('A 'b ('A list 'b -> 'A list 'c 'b) ('A list 'b -> 'A list 'b bool) -> 'A list)
{{
  desc:
    generates a function
}}
{ [nil bury [consd] compose] dip whilen pop }

define rev : (list -> list)
{{
  desc:
    reverses a list
}}
{ nil [cons] fold }

define small : (list -> list bool)
{{
  desc:
    Returns true if a list contains one element or is empty
}}
{ empty [true] [rest empty popd] if }

define split : ('A list ('A list list 'b 'b -> 'A list list 'c bool) -> 'A list list)
{{
  desc:
    Splits a list into two new lists
}}
{
  nil bury nil bury
  [dup] rcompose
  [[swap [cons] dip] [cons] if] compose
  gfold
}

define cons_first : (list 'a -> list)
{{
  desc:
    Appends item to first list in a pair of lists
  test:
    in: [1 2] list [3 4] list pair 5 cons_first
    out: [1 2 5] list [3 4] list pair
}}
{ [unpair] dip cons pair }

define cons_second : (list 'a -> list)
{{
  desc
    Appends item to second list in a pair of lists
  test:
    in: [1 2] list [3 4] list pair 5 cons_second
    out: [1 2] list [3 4 5] list pair
}}
{ [unpair] dip swap [cons] dip pair }

define move_head : (list list -> list list)
{{
  desc:
    Copies the head from one list to another.
  test:
    in: [1 2] list [3 4] list move_head
    out: [1 2 3] list [3] list
}}
{ uncons swap [cons] dip }

define index_of : (list 'a -> list int)
{{
  desc:
    Returns the index of a value in a list or the size of the list
    if not found
}}
{ [neq] papply count_while }

define split_at : (list int -> list list)
{{
  desc:
    splits a list in two at an index, the top result contains the second half
    sand the second result contains the first half of the original list
}}
{ nil bury [move_head] swap repeat }

define dhead : (list -> list any)
{{
  desc:
    Returns the head of a list, leaving the original list on the stack.
  test:
    in: [1 2] list dhead
    out: [1 2] list 2
}}
{ first }

define dtail : (list -> list list)
{{
  desc:
    Returns the tail of a list, leaving the original list on the stack.
  test:
    in: [1 2 3] list dtail
    out: [1 2 3] list [1 2] list
}}
{ rest }

define head_eq : (list any -> list bool)
{{
  test:
    in: [1 2] list 2 head_eq popd
    out: true

  test:
    in: [1 2] list 1 head_eq popd
    out: false
}}
{ [dhead] dip eq }


//=============================================================================
// Infinite list generators

define range : (int int -> list)
{ [] range_gen }

define n : (int -> list)
{ 0 swap range }

define naturals : ( -> list)
{ 0 [inc] [pop true] gen }

define odds : ( -> list)
{ 1 [2 +] [pop true] gen  }

define evens : ( -> list)
{ 0 [2 +] [pop true] gen  }

define negatives : ( -> list)
{ 1 neg [dec] [pop true] gen }

define zeros : ( -> list)
{ 0 repeater }

define ones : ( -> list)
{ 1 repeater }