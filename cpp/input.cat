// Auto-Generated Level-1 Cat Library with Tests
// Generated by Cat interpreter 0.14.1
// on Monday, May 28, 2007
// http://www.cat-language.com

// Applies a unary function to the top item on the stack.
// [$A] apply == $A
define apply  : ('A ('A -> 'B) -> 'B)
{ true swap [] if }

// Applies a unary function to the top two items on the stack.
// $a $a $B apply2 == $a $B $a $B
define apply2  : ('a 'a ('a -> 'b) -> 'b 'b)
{ under apply [apply] dip }

// Executes a function, first temporarily removing the next item on the stack.
// $a [$B] dip == $B $a
define dip  : ('A 'b ('A -> 'C) -> 'C 'b)
{ swap quote compose apply }

// Classical B combinator, a.k.a. Bluebird
// [$A] [$B] [$C] b == [[$A] $B] $C
define b{ [k] [[s] k] s }

// Classical C combinator, a.k.a. Cardinal
// [$A] [$B] [$C] c == [$B] [$A] $C
define c{ [[k] k] [[s] [b] b] s }

// D combinator, a.k.a. Dove
// [$A] [$B] [$C] [$D] d == [[$A] $B] [$C] $D
define d{ [b] b }

// Classical I combinator, a.k.a. Identity
// [$A] i == $A
define i  : ('A ('A -> 'B) -> 'B)
{ [k] [k] s }

// Classical K combinator used to represent True, a.k.a. Kestrel
// [$A] [$B] k == $B
define k  : ('A 'b ('A -> 'C) -> 'C)
{ [pop] dip }

// KI combinator, used to represent False, a.k.a. Kite
// [$A] [$B] ki == $A
define ki  : ('A ('A -> 'B) 'c -> 'B)
{ [i] k }

// L combinator, a.ka. Lark
// [$A] [$B] l == [[$A] $A] $B
define l{ [m] [b] c }

// Self-applicative or recursive combinator, a.k.a.  Mockingbird.
// [$A] m == [[$A] $A]
define m  : (f=(f -> 'A) -> 'A)
{ dup apply }

// O combinator, a.k.a. Owl
// [$A] [$B] o == [[$B] $B] $A
define o{ [i] s }

// R combinator, a.k.a. Robin
// [$A] [$B] [$C] r == [$C] [$A] $B
define r{ [t] [b] b }

// Classical S combinator, a.k.a. Starling
// [$A] [$B] [$C] s == [[$A] $B] [$A] $C
define s{ peek swap [curry] dip2 apply }

// T or reverse application combinator, a.k.a. Thrush.
// [$A] [$B] t == [$B] $A
define t{ [i] c }

// Turing's fixed point combinator.
// [$A] [$B] u == [[$B] [$A] [$A] $B] $A
define u{ [o] l }

// V combinator, a.k.a. Vireo
// [$A] [$B] [$C] v == [$B] [$C] $A
define v{ [t] [c] b }

// Classical W combinator, a.k.a. Warbler
// [$A] [$B] [$C] b == [[$A] $B] $C
define w{ [[r] [m] b] c }

// Classical fix-point Y combinator, a.k.a. Sage Bird or Why Bird
// [$A] y == [[$A] y] $A
define y  : ('A f=('A f -> 'B) -> 'B)
{ dup quote [y] compose swap apply }

// Executes a boolean ""and"" operation.
// $a $b and == $a [$b] [false] if
define and  : (bool bool -> bool)
{ quote [false] if }

// Executes a boolean ""nand"" operation.
// $a $b and == $a [$b not] [true] if
define nand  : (bool bool -> bool)
{ and not }

// Executes a boolean ""nor"" operation.
// $a $b nor == $a [false] [$b not] if
define nor  : (bool bool -> bool)
{ or not }

// Executes a boolean ""not"" operation.
// true not == false; false not == true;
define not  : (bool -> bool)
{ [false] [true] if }

// Executes a boolean ""or"" operation.
// $a $b or == $a [true] [$b] if
define or  : (bool bool -> bool)
{ [true] swap quote if }

// Compares top value to zero, leaving the value on the stack.
// $a eqz == $a $a 0 eq
define eqz  : (int -> int bool)
{ dup 0 eq }

// Creates a function that tests an argument for equality with a specific value leaving the argument on the stack.
// $a eqf == [dup $a eq]
define eqf  : ('a -> ('a -> 'a bool))
{ [dupd eq] curry }

// Compares top items on the stack for inequality.
// $a $b neq == $a $a eq not
define neq  : ('a 'a -> bool)
{ eq not }

// Creates a function that tests an argument for inequality with a specific value leaving the argument on the stack.
// $a neqf == [dup $a neq]
define neqf  : ('a -> ('a -> 'a bool))
{ [dupd neq] curry }

// Checks top value for inequality with zero, leaving the value on the stack.
// $a eqz == $a $a 0 neq
define neqz  : (int -> int bool)
{ dup 0 neq }

// Fixes a function's top argument to a constant value.
// $a [$B] curry == [$a $B]
define curry  : ('a ('B 'a -> 'C) -> ('B -> 'C))
{ [quote] dip compose }

// Fixes a function's top two arguments to constant values.
// $a $b [$C] curry2 == [$a $b $C]
define curry2  : ('a 'b ('C 'a 'b -> 'D) -> ('C -> 'D))
{ curry curry }

// Swaps then composes two functions.
// [$A] [$B] rcompose == [$B $A]
define rcompose  : (('A -> 'B) ('C-> 'A) -> ('C -> 'A))
{ swap compose }

// Fixes a function's top argument to a constant value.
// [$A] $b rcurry == [$B $a]
define rcurry  : (('A 'b -> 'C) 'b -> ('A -> 'C))
{ curry swap }

// Executes a loop a number of times, passing the loop count.
// [$A] $b for == 0 [[$A] dip] [dup $b neq] while
define for  : ('A ('A int -> 'A) int -> 'A)
{ swap [dip inc] curry [dup] rcompose swap neqf 0 bury while pop }

// Executes a function a number of times, pushing a value from a list each time. Very similar to fold. 
// () [$A] foreach == id; ($A $b) [$C] foreach == $b $C ($A) [$C] foreach
define for_each  : ('A list ('A 'b -> 'A) -> 'A)
{ [uncons swap] rcompose [dip] curry [empty not] while pop }

// Executes a function a number of times.
// [$A] 0 repeat == id; $A [$B] $c repeat == $B $A [$B] $c dec repeat;
define repeat  : ('A ('A -> 'A) int -> 'A)
{ swap [dip dec] curry [neqz] while pop }

// Executes a reverse for loop which counts down from some value to one.
// [$A] 0 for == id; [$A] $b for == $b $A [$A] $b dec for
define rfor  : ('A ('A int -> 'A) int -> 'A)
{ swap [dip dec] curry [dup] rcompose whilenz pop }

// Repeatedly executes a function, while the predicate returns true.
// [$A][$B] while == $B [$A [$A] [$B] while][ ] if
define while  : ('A ('A -> 'A) ('A -> 'A bool) -> 'A)
{ [dip swap] curry swap [dip m] curry quote compose [[pop] if] compose m }

// Repeatedly executes a function, while the predicate returns false.
// [$A] [$B] whilen == [$A] [$B not] while
define whilen  : ('A ('A -> 'A) ('A -> 'A bool) -> 'A)
{ [not] compose while }

// Repeatedly executes a function, while the list on the top of the stack is not empty.
// [$A] whilene == [$A] [empty not] while
define whilene  : ('A list ('A list -> 'A list) -> 'A)
{ [empty not] while }

// Repeatedly executes a function, while the integer on the top of the stack is not zero.
// [$A] whilenz == [$A] [neqz] while
define whilenz  : ('A int ('A int -> 'A int) -> 'A)
{ [neqz] while }

// Concatenates two lists.
// ($A) ($B) cat == ($A $B)
define cat  : (list list -> list)
{ rev [cons] fold }

// Returns the number of items in a list.
// ($A $b) count == ($A) count inc; () count == 0
define count  : (list -> list count)
{ 0 [pop inc] fold }

// Returns how many of the first elements satisfy a predicate
// () [$A] count_while == 0; ($A $b) [$C] count_while == $b $C $A [$C] count_while [inc] [] if
define count_while  : (list ('a -> bool) -> list int)
{ dupd 0 bury [[inc] dip] swap [uncons] rcompose quote [empty not] rcompose [[false] if] compose }

// Removes a number of items from the front of a list.
// ($A $b) 0 drop = ($A); ($A $b) $c drop == ($A $c dec drop)
define drop  : (list int -> list)
{ [[tail] dip dec] whilenz pop }

// Drops items from a list while the predicate is satisfied.
// () [$A] drop_while == (); ($A $b) [$C] drop_while  == $b $C [($A [$C] drop_while)] [($A)] if
define drop_while  : (list ('a -> bool) -> list)
{ dupd count_while drop }

// Returns true if a list contains no items.
// ($A) empty == ($A) count 0 eq
define empty  : (list -> list bool)
{ count 0 eq }

// Creates a list containing elements of a source list, for which a predicate returns true.
// ($A $b) [$C] filter == $b $C if ($A [$C] filter $b) ($A [$C] filter)
define filter  : (list ('a -> bool) -> list)
{ [rev] dip [[cons] [] if] compose [dup] rcompose nil swap fold }

// Returns first item in a list.
// ($A $b) first == ($A $b) $b
define first  : (list -> list var)
{ dup uncons popd }

// Concatenates all children in a list of lists.
// () flatten == (); ($A ($b)) flatten == ($A flatten $b)
define flatten  : (list -> list)
{ nil [cat] fold }

// Applies a binary function to the first item in a list with an accumulated value. It removes the first item and repeats until the list is empty.
// () $a [$B] fold == $a; ($A $b) $c [$D] fold == $c $b $D ($A) [$D] fold
define fold  : (list 'a ('a 'a -> 'a) -> 'a)
{ swapd [dip] curry [uncons swap] rcompose whilene pop }

// Creates a new list, and appends an item to a list if the predicate is true. It then applyies a transform to the last value and repeats.
// $a [$B] [$C] gen == $a $C [($a $a $B [$B] [$C] gen)] [()] if
define gen  : ('a ('a -> 'a) ('a -> bool) -> list)
{ nil bury [[cons] dip rcompose] dip [dup] rcompose }

// Replace a list with the first item in it.
// ($A $b) head == $b
define head  : (list -> var)
{ uncons popd }

// Returns the last item in a list.
// ($A) last == ($A) count dec nth
define last  : (list -> list var)
{ count dec nth }

// Creates a new list by applying a transform function to each item in a list.
// $a [$B] map == $a [$B] rmap rev
define map  : (list ('a -> 'b) -> list)
{ rmap rev }

// Returns the middle item in a list.
// ($A) mid == ($A) count 2 div_int nth
define mid  : (list -> list var)
{ count 2 div_int nth }

// Moves the head of one list to the next.
// ($A) ($B $c) move_head == ($A $c) ($B)
define move_head  : (list list -> list list)
{ uncons swap cons }

// Creates a list of consecutive integers from 0 to some number minus one.
// 0 n == (); $a n = ($a dec n $a)
define n  : (int -> list)
{ nil swap dup [dec cons] swap repeat }

// Returns the nth item in a list.
// ($A $b) 0 nth == ($A $b) $b; ($A $b) 0 nth
define nth  : (list int -> list var)
{ dupd take head }

// Creates a list containing two items.
// $a $b pair == ($a $b)
define pair  : ('a 'b -> list)
{ [unit] dip cons }

// Reverses a list.
// ($A $b) rev == ($b $A rev); () rev == ()
define rev  : (list -> list)
{ nil [cons] fold }

// Constructs a map of the reverse of a list.
// [$A] rmap == nil [cons] fold
define rmap  : (list ('a -> 'b) -> list)
{ nil [cons] fold }

// Creates a new list by replacing an item at a given index with a new value.
// ($A $b) $c 0 set_at == ($A $c); ($A $b) $c $d set_at == ($A $c $d dec set_at $b)
define set_at  : (list var int -> list)
{ swapd split_at [rest swons] dip cat }

// Returns true if a list contains one or zero items.
// ($A) small == ($A) count 1 lteq
define small  : (list -> list bool)
{ count 1 lteq }

// Splits a list in two according to a predicate function.
// ($A) [$B] split == ($A) [$B] (filter) ($A) [$B not] (filter)
define split  : (list ('a -> bool) -> list list)
{ dup2 [filter] dip2 [not] compose filter }

// Splits a list in two at a specific index.
// ($A) 0 split_at == ($A) (); ($A $b) $c split_at == ($A) $c dec split_at $b cons
define split_at  : (list int -> list list)
{ nil bury [move_head] swap repeat }

// Remove first item in a list.
// ($A $b) tail == ($A)
define tail  : (list -> list)
{ uncons pop }

// Creates a list from the first n items in another list.
// ($A $b) 0 take = (); ($A $b) $c take == ($A $c dec take $b)
define take  : (list int -> list)
{ nil bury [[move_head] dip dec] whilenz pop rev }

// Takes items from a list while the predicate is satisfied.
// () [$A] take_while == (); ($A $b) [$C] take_while  == $b $C [($A [$C] take_while $b)] [()] if
define take_while  : (list ('a -> bool) -> list)
{ dupd count_while take }

// Generates a list from a binary function and initial value.
// $a [$B] [$C] unfold == $a $C [($a $a $B [$B] [$C] unfold)] [()] if
define unfold  : ('a ('a -> 'a 'a) ('a -> 'a bool) -> list)
{ [nil bury [consd] compose] dip whilen }

// Removes first two items from a list and removes it.
// ($A $b $c) unpair == $b $c
define unpair  : (list -> var var)
{ uncons [head] dip }

// Creates a list containing one item.
// $a unit == ($a)
define unit  : ('a -> list)
{ nil swap cons }

// $a $b $c bury == $c $a $b
define bury  : ('a 'b 'c -> 'c 'a 'b)
{ swap swapd }

// $a $b $c dig == $b $c $a
define dig  : ('a 'b 'c -> 'b 'c 'a)
{ swapd swap }

// $a $b dup2 == $a $b $a $b
define dup2  : ('a 'b -> 'a 'b 'a 'b)
{ over over }

// $a $b dupd == $a $a $b
define dupd  : ('a 'b -> 'a 'a 'b)
{ [dup] dip }

// $a $b over == $a $b $a
define over  : ('a 'b -> 'a 'b 'a)
{ dupd swap }

// $a $b $c peek == $a $b $c $a
define peek  : ('a 'b 'c -> 'a 'b 'c 'a)
{ [dupd] dip dig }

// $a $b $c poke == $c $b
define poke  : ('a 'b 'c -> 'c 'b)
{ [popd] dip swap }

// $a $b pop2 == id
define pop2  : ('a 'b -> )
{ pop pop }

// $a $b popd == $b
define popd  : ('a 'b -> 'b)
{ [pop] dip }

// $a $b $c $d swap2 == $c $d $a $b
define swap2  : ('a 'b 'c 'd -> 'c 'd 'a 'b)
{ [bury] dip bury }

// $a $b $c swapd == $b $a $c
define swapd  : ('a 'b 'c -> 'b 'a 'c)
{ [swap] dip }

// $a $b under == $b $a $b
define under  : ('a 'b -> 'b 'a 'b)
{ dup swapd }

// $a inc == {$a-1}
define dec  : (int -> int)
{ 1 sub_int }

// $a inc == {$a+1}
define inc  : (int -> int)
{ 1 add_int }

// $a $b sub_int == {$a - $b}
define sub_int  : (int int -> int)
{ neg_int add_int }

// $a $b min_int == $a $b lt_int [$a] [$b] if
define min_int  : (int int -> int)
{ dup2 gt [pop] [popd] if }

// $a $b max_int == $a $b gt_int [$a] [$b] if
define max_int  : (int int -> int)
{ dup2 gt [popd] [pop] if }

// $a $b gt_int == {$a > $b}
define gt_int  : (int int -> bool)
{ lteq_int not }

// $a $b gteq_int == {$a >= $b}
define gteq_int  : (int int -> bool)
{ lt_int not }

// $a $b lteq_int == {$a <= $b}
define lteq_int  : (int int -> bool)
{ dup2 eq lt_int or }

// Tests

define test { apply [dup halt] [inc] if }

define run_tests
{
	[1 2 add_int 3 eq] test
	[[1] [inc] compose apply 2 eq] test
	[nil 1 cons uncons swap pop 1 eq] test
	[2 dup add_int 4 eq] test
	[1 1 eq] test
	[false [false] [true] if] test
	[true [1] [2] if 1 eq] test
	[3 5 lt_int] test
	[5 3 mod_int 2 eq] test
	[5 3 mul_int 15 eq] test
	[5 neg -5 eq] test
	[nil nil eq] test
	[3 5 pop 3 eq] test
	[true 1 quote 2 quote 1 eq] test
	[1 2 swap pop 2 eq] test
	[true [true] [false] if] test
	[nil 2 cons 1 cons uncons pop uncons swap pop 2 eq] test
	[[1] apply 1 eq] test
	[1 3 [inc] app2 pop 2 eq] test
	[1 3 [inc] dip pop 2 eq] test
	[[1] [apply 2 mul_int] [apply] b 2 eq] test
	[[dup] [12] [pop] c apply 12 eq] test
	[true true and] test
	[true false nand] test
	[false false nor] test
}
