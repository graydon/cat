// MetaCat optimization macros
// Public domain
// by Christopher Diggins

// Simple optimizations
macro { noop } => { }
macro { id } => { }
macro { swap swap } => { }
macro { dup pop } => { }
macro { not not } => { }
macro { quote apply } => { }
macro { dup swap } => { dup }
macro { dup eq } => { pop true }

// dup ('a -> 'b) pop patterns
macro { dup quote pop } => { }
macro { dup swap pop } => { }
macro { dup inc pop } => { }
macro { dup unit pop } => { }
macro { dup $a compose pop } => { }
macro { dup $a pair pop } => { }
macro { dup $a add pop } => { }
// ... the list goes on and on.

// Combinator fusions
macro { apply $a apply } => { $a compose apply }
macro { dip $a dip } => { $a compose dip }
macro { apply $a $b dip } => { $a compose apply $b }

// This is due to the identity
// {$a swap} => {[$a] dip}
macro { swap $a dip } => { quote $a compose dip }
macro { swap quote dip } => { }
macro { quote dip swap } => { }
macro { dup quote dip } => { dup }

// Identities
macro { $b $a swap } => { $a $b }
macro { $a pop } => { }
macro { $b [$A] dip } => { $A $b }
macro { true [$B] [$A] if } => { $B }
macro { false [$B] [$A] if } => { $A }
macro { [$A] apply } => { $A }
macro { $a quote } => { [$a] }
macro { [$B] [$A] compose } => { [$B $A] }
macro { [$B] [$A] rcompose } => { [$A $B] }
macro { $b [$A] curry } => { [$b $A] }
macro { [$B] $a rcurry } => { [$a $B] }
macro { $b [$A] app2 } => { $A $b $A }

// Loop unrolling
// Not currently performed because of the potential performance hit
// This is a tricky optimization to apply properly.
// macro { [$A] [$B] while } => { $B [$A [$A] [$B] while] [] if }

// Boolean primitives
macro { true not } => { false }
macro { false not } => { true }
macro { true and } => { }
macro { false and } => { pop false }
macro { true or } => { pop true }
macro { false or } => { }

// Reduction based on the property of commutativity
macro { swap and } => { and }
macro { swap or } => { or }
macro { swap add_int } => { add_int }
macro { swap mul_int } => { add_int }
macro { swap add_byte } => { add_byte }
macro { swap mul_byte } => { add_byte }
macro { swap add_dbl } => { add_dbl }
macro { swap mul_dbl } => { add_dbl }

// short-circuit boolean applyuation
macro { $a and } => { [$a] [false] if }
macro { $a or } => { [true] [$a] if }

// List primitivies
macro { cons uncons } => { }
macro { [$B] to_list [$A] to_list cat } => { [$B $A] to_list }
macro { [$B] to_list $a cons } => { [$B $a] to_list }
macro { $a cons head } => { pop $a }
macro { $a cons tail } => { }
macro { $a cons first } => { $a cons first $a }
macro { $a cons rest } => { dup $a cons swap }
macro { $b $a pair } => { [$b $a] to_list }

// Higher order list primitives fusions
macro { $b map $a map } => { $b $a compose map }
macro { $b filter $a filter } => { [dup $b apply $a [pop false] if] filter }

// Nil list special cases
macro { nil $a filter } => { nil }
macro { nil $a map } => { nil }
macro { nil $b $a fold } => { $b }

// Unit list special cases
macro { nil $a cons } => { $a unit }
macro { $b unit $a filter } => { $b $a apply [$b unit] [nil] if }
macro { unit $a map } => { $a apply unit }
macro { $c unit $b $a fold } => { $b $c $a apply }
macro { unit rev } => { unit }
macro { unit head } => { }
macro { unit tail } => { nil }

// Pair list special cases
macro { unit $b cons } => { $a $b pair }
macro { $b pair $a map } => { $a apply $b $a apply pair }
macro { $d $c pair $b $a fold } => { $b $c $a apply $d $a apply }
macro { pair rev } => { swap pair }
macro { pair unpair } => { }
macro { pair head } => { popd }
macro { pair rest } => { pop unit }

// Here are some standard library shuffling functions
macro { $b $a nip } => { $a }
macro { $b $a popd } => { $a }
macro { $b $a dupd } => { $b $b $a }
macro { $c $b $a swapd } => { $b $c $a }
macro { $c $b $a dig } => { $b $a $c }
macro { $c $b $a bury } => { $a $c $b }
macro { $c $b $a poke } => { $a $b $a }
macro { $c $b $a peek } => { $c $b $a $c }


