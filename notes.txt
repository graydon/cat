TODO
====
- Test everything. 
- Get MapReduce to work.
- Make sure the article is correct. 

- "eval" primitive
- self-interpreter. 


//=


- I reallly need to have 

After rewriting: dup [dup [[dup] dip [[id empty] dip [id] papply] papply dip] di
p] dip  dip [[[id uncons] dip id] dip id apply] dip id  papply papply papply pap
ply if

>> define fold(xs x f) { xs empty [x] [xs uncons x f apply f fold] if }


//

Ideas:

- non duplicatable types
- internet connectivity
- sockets 
- files
- concurrency! 
- stack switching / continuations
- re-entrant compiler. 
- "compile" as a primitive? 

// 

todo: 
- specify the VM 
- update the specification
- automatically create a bunch of documents. 
- create a text output of everything
- find a way to redirect standard out
- finish the new "split" function.
- find a way to deal with associativity./ 

//

- Talk about predicates. 
- Talk about folds. 
- Talk about maps.

//

High Pri
- replace usage of "List<Function>" with "CatExpr" where appropriate
- replace the usage of "FunctionalList" with a list class that is a lot more sane, and easy to verify. Maybe a nice little list class.
- Get local defines to work. 
- Figure out how "macros" should fit into all of this. 
- Fix the parser: it is a mess.
- Functions should really be dynamic look-ups (much easier)
- Execution needs to be based on ASTs. 
- Give the thing an AST, and run it. 
- I need to generate new documentation, and I want to do it using Cat reflection.
- I need to implement and document a reflection API
- I want to know what the test coverage is.
- I want self-testing to be done within Cat
- I need a switch statement
- I need a proper representation of lists as functions 

Med Pri
- Rewrite primitives 
- come up with a mechanism for expressing external APIs 
- What is the syntax of primitives and external> 

Notes:
- I am thinking that somewhere, somehow, there is something I can do about ...
- Whatever. What I need to remember is that ast nodes are actually the things I want to pass around as expressions.
- My main concern is the fact that I might inadvertently change things, where I should make copies.
- How much processing should a man do? 
- I think I may have a superfluous layer of processing.
- It looks like I can probably simplify things a lot. 
- What I am not happy about is the usage of strings as labels. 
- external fu { } 
- What about creating new types. This seems kind of important, how am I going to do that. 
- Can a type really be defined by its constructor. e.g. every function is a type. 
- deftype fu { 'a 'b 'c -> 'e 'f) { }
- what about type and name overloading? 
- dynamic type dispatch would be very nice. 
- multi-methods in Cat? Why the fuck not? 
- Well the big problem I forsee, is the fact that it would require dynamic type information, and it would 
	require type signatures. 
- I have a function for performing manual dispatch
- What about using macros to customize syntax. 
- This is very tempting. I can see: x + y => x y + 
- This gives me an infix notation for free. 
- There is an interesting article: why rewriting ruels are so important.

declare cons : (['B 'a] 'a -> ['B 'a]) 
{{ 
	desc: 
	  appends an item to a list
	test:
	  in: [1] 2 cons 
	  out: [1 2]	  
	level:
	  0
	tags:
	  primitive, list
}}

declare uncons : (['B 'a] -> ['B 'a] 'a)
{{ 
	desc: 
	  separates a list into its head and tail
	test:
	  in: [1] 2 cons 
	  out: [1 2]	  
	level:
	  0
	tags:
	  primitive, list	
}} 

declare listeq : (['B 'a] ['C 'a] -> bool)
{{
	desc: 
	  compares two lists for equality
	test:
	  in: [1 2] [1 2] listeq
	  out: true
	test:
	  in: [1 2] [2 1] listeq
	  out: false
	test:
	  in: [1 2] [1 2 3] listeq
	  out: false
	level:
	  0
	tags:
	  primitive, list	
}}

declare nil : ( -> [[] 'a])
{ [[nil] nil] }

declare unit : ('a -> 'a*)
{{
	desc: 
	  constructs a list containing a single item
	test:
	  in: 1 unit 
	  out: [1]	  
	level:
	  0
	tags:
	  primitive, list	
}}

declare empty : ('a* -> 'a* bool)
{{
	desc: 
	  returns true if the list contains no elements
	test:
	  in: [1] empty 
	  out: false
	level:
	  0
	tags:
	  primitive, list	
}}

- Now what about nil? What is the type of the empty list? I can construct many different kinds of empty lists.
- There is always the issue of "nil". 
- is "nil 12 cons" a special type? Perhaps "cons" is polymorphic on the second variable? In the sense that 
	it can either by a "nillist", or an "Xlist". Where x is something else. 
- Do I want two different kinds of lists, "any" and something else?
- "nil 12 listeq" won't typecheck. So what do I do? 
- It seems that what I need to keep in mind is that a list is actually a discriminated union. "null | list['a]"

external cons : ('b 'a -> ['b 'a]) 
external uncons : ([ -> ]) 

[[] 'a] == [[[] 'a] 'a]
=> [] => [[] 'a]

Internally what am I going to do? 
Some kind of special class? 
I can't see that it will work by simply changing the defintion of "equal". 

- 'b* and 'a* can be compared, can't they?
- well there are improper lists, and there are proper lists. 

What if 

cons : (['B] 'a -> [['B] 'a])
uncons : ([['B] 'a] -> ['B] 'a)
listeq : ([['B] 'a] [['C] 'a] -> bool)

A list is a function that return a value and a list. 

uncons : ([['B] 'a] -> ['B] 'a) 

It's a recursive function? 

uncons : (( -> 'B 'a) -> ( -> 'B 'a) 'a))

Actually "uncons" is the type of a list. 
All lists have type: (( -> 'B 'a) -> ( -> 'B 'a) 'a))

That means that cons has to have type: 

cons : ((( -> 'B 'a) -> ( -> 'B 'a) 'a)) 'a -> (( -> 'B 'a) -> ( -> 'B 'a) 'a)))

A short-hand for ( -> 'B) could be ['B] 

Then: 

cons : ((['B] -> ['B 'a] 'a)) 'a -> (['B 'a] -> [B 'a] 'a)))

Seems like there is a level too much though. Why not just: 

cons : (['B 'a] 'a -> ['B 'a])
uncons : (['B 'a] -> ['B 'a] 'a)

This seems to me to be perfectly reasonable. 

It will probably also work perfectly.
















	    
		
	  

Idea
- It would be nice to be able to show how to generate non-stack code from a Cat AST.
- In other words, once all the stack stuff is done. 
- I would like to generate documentation for the project 
- I would like to see a class diagram for the project as well. 
- It would be really nice, if there was a way for people to create their own syntax 
- It would be nice to post an article about the PEG parser on CodeProject (parsing made easy)
- 


    /*
        public string GetXmlDoc()
        {
            string s = "<?xml version='1.0'?>";
            s += GetXmlText();
            return s;
        }

        public string GetXmlText()
        {
            string s = "<" + msLabel + ">\n";

            if (GetNumChildren() == 0)
            {
                s += ToString();
            }
            else
            {
                foreach (PegAstNode node in mChildren)
                {
                    s += node.GetXmlText();
                }
            }
            s += "</" + msLabel + ">\n";
            return s;
        }

    */
    

/*
class CatEvaluator
{
    // Fields:
    // - macro list
    // - context stack
    // - meta-data 
    // - stack
    // - function definition list
    // - primitive list 

    // List<string, string> macros;
    List<Context> contexts;
    //List<Met> metadata;
    Dictionary<string, string> metadata;
    Dictionary<string, string> primitives;

    public CatEvaluator()
    {
    }

    public bool IsFunctionCall(AstStatement x)
    {
        // TODO: check if this is a named defined function (not declaration) or quotation 

        return true;
    }

    public List<AstStatement> GetFunctionBody(AstStatement x)
    {
        Trace.Assert(x is AstDef);
        AstDef def = x as AstDef;
        return def.mStatements;
    }

    public void Evaluate(string s)
    {
        List<AstStatement> statements = CatParser.Parse(s);
        Evaluate(statements);
    }

    public void Evaluate(List<AstStatement> statements)
    {
        int n = 0;
        while (n < statements.Count)
        {
            AstStatement statement = statements[n++];

            // First look for function calls in tail-call position
            if (n == statements.Count && IsFunctionCall(statement))
            {
                statements = GetFunctionBody(statement);
                n = 0;
            }
            else
            {
                if (IsFunctionCall(statement))
                {
                    Evaluate(GetFunctionBody(statement));
                }
                else
                {
                    Evaluate(statement);
                }
            }
        }
    }

    public void Evaluate(AstStatement statement)
    {
        switch (statement.GetLabel())
        {
            case AstLabel.Def:
                break;
            case AstLabel.Int:
                break;
            case AstLabel.Bin:
                break;
            // TODO: finish
            default:
                throw new Exception("Unrecognized statement node type: " + ast.GetLabel().ToString());
        }
    }

    public void Evaluate(List<Function> fxns)
    {
        for (int i = 0; i < fxns.Count; ++i)
        {
            // Is this a call in tail-call position
            if (i == fxns.Count - 1 && fxns[i].HasSubFxns())
            {
                fxns = fxns[i].GetSubFxns();
                i = 0;
            }
            else
            {
                Evaluate(fxns[i]);
            }
        }
    }

    public void Evaluate(Function f)
    {
        if (f.HasSubFxns())
        {
            Evaluate(f.GetSubFxns());
        }
        else
        {

        }
    }

    public void Evaluate(string s)
    {
        Evaluate(CatParser.Parse(s));
    }

    #region parsing functions
    public static List<Function> TermsToFxns(List<AstExpr> terms, DefinedFunction def)
    {
        List<Function> fxns = new List<Function>();
        foreach (AstExpr child in terms)
        {
            Function f = ExprToFunction(child, def);
            fxns.Add(f);
        }
        return fxns;
    }

    private static Quotation MakeQuoteFunction(AstQuote node, DefinedFunction def)
    {
        return new Quotation(TermsToFxns(node.mTerms, def));
    }

    private static Quotation MakeQuoteFunction(AstLambda node, DefinedFunction def)
    {
        CatPointFreeForm.Convert(node);
        return new Quotation(TermsToFxns(node.mTerms, def));
    }

    private static Function ExprToFunction(AstExpr node, DefinedFunction def)
    {
        if (node is AstInt)
            return new PushInt((node as AstInt).GetValue());
        else if (node is AstBin)
            return new PushInt((node as AstBin).GetValue());
        else if (node is AstHex)
            return new PushInt((node as AstHex).GetValue());
        else if (node is AstFloatNode)
            return new PushValue<double>((node as AstFloatNode).GetValue());
        else if (node is AstString)
            return new PushValue<string>((node as AstString).GetValue());
        else if (node is AstCharNode)
            return new PushValue<char>((node as AstCharNode).GetValue());
        else if (node is AstName)
        {
            string s = node.ToString();
            Function f = Executor.Main.GetGlobalContext().Lookup(s);
            if (s.Equals("self") || (def != null && s.Equals(def.GetName())))
                return new SelfFunction(def);
            if (f == null)
                throw new Exception("could not find function " + s);
            return f;
        }
        else if (node is AstQuote)
            return MakeQuoteFunction(node as AstQuote, def);
        else if (node is AstLambda)
            return MakeQuoteFunction(node as AstLambda, def);
        else
            throw new Exception("node " + node.ToString() + " does not have associated function");
    }

    // TODO: remove
    private static void ProcessDefinition(AstDef node)
    {
        // NOTE: should this really be here? 
        if (Config.gbAllowNamedParams)
            CatPointFreeForm.Convert(node);
        else if (node.mParams.Count > 0)
            throw new Exception("named parameters are not enabled");

        DefinedFunction def = new DefinedFunction(node.mName);
        Executor.Main.GetGlobalContext().AddFunction(def);

        // NOTE: this is a broken algorithm. I'm leaving it here for reference
        // in case I want to do something similar later on.
        //RewriteRecursiveCalls(node.mTerms, def);

        def.AddFunctions(TermsToFxns(node.mTerms, def));

        // Construct a representation of the meta data if neccessary
        if (node.mpMetaData != null)
            def.SetMetaData(new CatMetaDataBlock(node.mpMetaData));

        // Compare the inferred type with the declared type
        // This is a crtical part of the type checker.
        if (Config.gbTypeChecking && (node.mType != null))
        {
            CatFxnType declaredType = new CatFxnType(node.mType);
            def.SetTypeExplicit();

            if (!CatFxnType.CompareFxnTypes(def.mpFxnType, declaredType))
            {
                Output.WriteLine("type error in function " + def.GetName());
                Output.WriteLine("inferred type " + def.GetFxnType().ToPrettyString());
                Output.WriteLine("declared type " + declaredType.ToPrettyString());
                bool bTmp = CatFxnType.CompareFxnTypes(def.mpFxnType, declaredType);
                def.SetTypeError();

                // avoid an extra output of the type
                return;
            }
        }
        if (Config.gbShowInferredType)
        {
            if (def != null && def.GetFxnType() != null)
                Output.WriteLine(def.GetName() + " : " + def.GetFxnType().ToPrettyString());
        }
    }

    // TODO: remove
    private static void ProcessMacro(AstMacro node)
    {
        Macros.GetGlobalMacros().AddMacro(node);
    }

    // TODO: remove
    private static void ProcessNode(CatAstNode node, Executor exec)
    {
        if (node is AstExpr)
        {
            Function f = ExprToFunction(node as AstExpr, null);
            f.Eval(exec);
        }
        else if (node is AstDef)
        {
            ProcessDefinition(node as AstDef);
        }
        else if (node is AstMacro)
        {
            ProcessMacro(node as AstMacro);
        }
        else if (node is AstMetaDataBlock)
        {
            throw new Exception("meta-data blocks can only occur in definitions");
        }
        else
        {
            throw new Exception("Unhandled AST node type " + node.GetLabel());
        }
    }

    // TODO: remove
    public static void Parse(string s, Executor exec)
    {
        Peg.Parser parser = new Peg.Parser(s);

        try
        {
            bool bResult = parser.Parse(CatGrammar.CatProgram());
            if (!bResult)
                throw new Exception("failed to parse input");
        }
        catch (Exception e)
        {
            Output.WriteLine("Parsing error occured with message: " + e.Message);
            Output.WriteLine(parser.ParserPosition);
            throw e;
        }

        Peg.PegAstNode node = parser.GetAst();

        foreach (Peg.PegAstNode child in node.GetChildren())
            ProcessNode(CatAstNode.Create(child), exec);
    }

    // TODO: remove
    public static List<AstExpr> ParseExpr(string s)
    {
        Peg.Parser parser = new Peg.Parser(s);

        try
        {
            bool bResult = parser.Parse(CatGrammar.CatProgram());
            if (!bResult)
                throw new Exception("failed to parse input");
        }
        catch (Exception e)
        {
            Output.WriteLine("Parsing error occured with message: " + e.Message);
            Output.WriteLine(parser.ParserPosition);
            throw e;
        }

        AstExprListNode tmp = new AstExprListNode(parser.GetAst());

        return tmp.mTerms;
    }
    #endregion

}
*/    

        public class TakeN : PrimitiveFunction
        {
            public TakeN()
                : base("take", "(list int -> list)", "creates a new list from the first n items")
            { }

            public override void Eval(Executor exec)
            {
                int n = exec.PopInt();
                CatList list = exec.TypedPop<CatList>();
                exec.Push(list.TakeN(n));
            }
        }

        public class DropN : PrimitiveFunction
        {
            public DropN()
                : base("drop", "(list int -> list)", "creates a new list without the first n items")
            { }

            public override void Eval(Executor exec)
            {
                int n = exec.PopInt();
                CatList list = exec.TypedPop<CatList>();
                exec.Push(list.DropN(n));
            }
        }

        public class TakeRange : PrimitiveFunction
        {
            public TakeRange()
                : base("take_range", "(list int int -> list)", "creates a new list which is a sub-range of the original")
            { }

            public override void Eval(Executor exec)
            {
                int count = exec.PopInt();
                int n = exec.PopInt();
                CatList list = exec.TypedPop<CatList>();
                exec.Push(list.TakeRange(n, count));
            }
        }

        public class TakeWhile : PrimitiveFunction
        {
            public TakeWhile()
                : base("take_while", "(list ('a -> bool) -> list)", "creates a new list by taking items while the predicate is true")
            { }

            public override void Eval(Executor exec)
            {
                Function f = exec.TypedPop<Function>();
                CatList list = exec.TypedPop<CatList>();
                exec.Push(list.TakeWhile(f.ToFilterFxn()));
            }
        }

        public class DropWhile : PrimitiveFunction
        {
            public DropWhile()
                : base("drop_while", "(list ('a -> bool) -> list)", "creates a new list by dropping items while the predicate is true")
            { }

            public override void Eval(Executor exec)
            {
                Function f = exec.TypedPop<Function>();
                CatList list = exec.TypedPop<CatList>();
                exec.Push(list.DropWhile(f.ToFilterFxn()));
            }
        }

        public class CountWhile : PrimitiveFunction
        {
            public CountWhile()
                : base("count_while", "(list ('a -> bool) -> list int)", "creates a new list by dropping items while the predicate is true")
            { }

            public override void Eval(Executor exec)
            {
                Function f = exec.TypedPop<Function>();
                CatList list = exec.TypedPeek<CatList>();
                exec.Push(list.CountWhile(f.ToFilterFxn()));
            }
        }

        public class RangeGen : PrimitiveFunction
        {
            public RangeGen()
                : base("range_gen", "(int int (int -> 'a) -> list)", 
                    "creates a lazy list from a range of numbers and a generating function")
            { }

            public override void Eval(Executor exec)
            {
                Function f = exec.TypedPop<Function>();
                int count = exec.PopInt();
                int n = exec.PopInt();
                exec.Push(CatList.RangeGen(f.ToRangeGenFxn(), n, count));
            }
        }

        public class Repeater : PrimitiveFunction
        {
            public Repeater()
                : base("repeater", "('a -> list)", 
                    "creates a lazy list by repeating a value over and over again")
            { }

            public override void Eval(Executor exec)
            {
                Object o = exec.Pop();
                exec.Push(CatList.MakeRepeater(o));
            }
        }

        public class Flatten : PrimitiveFunction
        {
            public Flatten()
                : base("flatten", "(list -> list)", "concatenates all sub-lists in a list of lists")
            { }

            public override void Eval(Executor exec)
            {
                CatList list = exec.TypedPop<CatList>();
                exec.Push(list.Flatten());
            }
        }
        #endregion
        /*
         * TODO: reintroduce this
         * 
        public class Unfold : PrimitiveFunction
        {
            public Unfold()
                : base("unfold", "('a ('a -> 'a) ('a -> bool) -> list)",
                    "creates a lazily evaluated list")
            { }

            public override void Eval(Executor exec)
            {
                Function term = exec.TypedPop<Function>();
                Function next = exec.TypedPop<Function>();
                Object init = exec.Pop();
                exec.Push(new Generator(init, next.ToMapFxn(), term.ToFilterFxn()));
            }
        }
         */

        public class Help : PrimitiveFunction
        {
            public Help()
                : base("#help", "( ~> )", "prints some helpful tips")
            { }

            public override void Eval(Executor exec)
            {
                Output.WriteLine("The following are the meta-commands for the Cat:");
                Output.WriteLine("  #exit - exits the interpreter");
                Output.WriteLine("  #clr - clears the stack");
                Output.WriteLine("  #defs - lists all defined functions");
                Output.WriteLine("  \"filename\" #load - loads and executes a Cat file");
                Output.WriteLine("  \"filename\" #save - saves a transcript of session");
                Output.WriteLine("  [...] #doc - provides documentation on an instruction");
                Output.WriteLine("  [...] #type - infers the type of a quotation");
                Output.WriteLine("  [...] #inline - performs inline expansion within a quotation");
                Output.WriteLine("  [...] #metacat - executes MetaCat rewriting rules");
                Output.WriteLine("  [...] #test - tests all instruction in a quotation");
                //Output.WriteLine("  [...] #o - optimizes a quotation");
                //Output.WriteLine("  [...] #partial - partially evaluates a quotation");
                //Output.WriteLine("  [...] #c - compiles a quotation into an assembly");
                //Output.WriteLine("  #run - runs a compiled assembly");
                Output.WriteLine("  #testall - tests all defined instruction");
                //Output.WriteLine("  #v - shows the session viewer");
            }
        }

        public class CommandHelp : PrimitiveFunction
        {
            public CommandHelp()
                : base("#doc", "(function ~> )", "prints documentation about a specific commands")
            { }

            public override void Eval(Executor exec)
            {
                MainClass.OutputHelp(exec.PopFunction());
            }
        }

        public class Defs : PrimitiveFunction
        {
            public Defs()
                : base("#defs", "( ~> )", "lists all documented definitions")
            { }

            public override void Eval(Executor exec)
            {
                MainClass.OutputDefs(exec);
            }
        }

        public static void ShowLogo()
        {
            if (!Config.gbReleaseVersion)
                WriteLine("WARNING: this is an unstable development build of Cat");
            
            WriteLine("");
            WriteLine("Cat Interpreter =^_^=");
            WriteLine("version " + Config.gsVersion);
            WriteLine("by Christopher Diggins");
            WriteLine("this software is released under the MIT license");
            WriteLine("the source code is public domain and available at");
            WriteLine("http://www.cat-language.com");
            WriteLine("");
            WriteLine("Type in #help for help and #exit to exit.");
            WriteLine("");
        }


    
- Other Stuff:
- How do I construct an empty list?
- Should I use the LC approach of list encoding: i.e. using the fold function

- God I hope I can convert from ints to Enum values. 

- What are statements looking like? They are expressions ... and other things
- I am going to have a problem with statements / expressions. 
- A function body consists of a list of statements, an expression skips over statements. 
- What I need to do is extract expressions from lists of statements.
- the evaluator evaluates a list of statements. What about the next step? 
- what are functions? 
- My type reconstructor works with a list of functions, so how do I get that? 
- Is there any problem with how I deal with functions? 
- How am I going to evaluate primitives? That is going to be a problem. 
- What is a function? Do I really want to simply evaluate a list of statements? 
- Statements create definitions, and other such things. 
- I don't want to reparse everything each time. I want to construct a function. 
- Currently I have a whole bunch of objects, each one contains a different function. We all agree, this is the wrong way to do things.
- The correct way, isn't that much more obvious. 
- There is an efficient way to deal with this, and an inefficient way.
- Do I want to create an extra data type? 
- This means that a statement list is converted into an expression.
- An expression then is executed. 
- This kind of makes sense. 
- I parse a string and I am going to get a sequence of statements
- I want to evaluate functions.
- Note that functions can't be changed. 
- So a statement list is converted to list of functions.
- What sucks is that I can't switch on the type. That is simply ridiculous. (Blog about it).

- What I want to do is be able to define lazy lists in Cat.
- It would be nice if I could have something similar for primitives.

==
Done: 

- Optimized ASTs to contain objects as labels instead of strings. At the Cat level I use an enumeration to speed up switch statement
- Rewrote the evaluator. It evalutes parse trees 
- Evaluator is now tail-call optimized 
- Removed the "compile" functionality
- Remove the incomplete code view and edit functionality
- Cleaned up a lot of unused code

About to do:
- rewrote handling of primitives (documented externally)
- can handle nested defines
- reflection API 
- documentation / testing is now done from Cat itself instead of the interpreter

Open Issues:
- Partial evaluator is still broken
- Declarations  
- Macros are broken because I can't lookup functions any more. The macro pattern should be a list of strings, which should be converted to functions 
	by the caller.
- There needs to be some kind of string to function.
- I need mutable lists
- I need to recreate some of the functional stuff. 
- I need generators again.
- I need to define primitives for Pair / Unit etc. 
- 
//

- I need an execution trace for when execution fails
- I need to assure that "map_reduce" works as it did in the Doctor Dobbs article
- I need to test my graphics
- I need to write the Heron to Cat translator.
- I want to write a Cat interpreter for different languages.

//

- better error messages when underflowing/overflowing the stack.