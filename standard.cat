// Cat Standard Library
// by Christopher Diggins
// http://www.cdiggins.com
// this file is public domain

//=============================================================================

define noop : ( -> )
{ }

//=============================================================================
// Function manipulation operators

// quote operation aliases
define constantly : ('a -> ( -> 'a))
{{
  desc:
    An alias for the quote instruction.
}}
{ quote }

define bind : ('a ('B 'a -> 'C) -> ('B -> 'C))
{{
  desc:
    Partial application function, bind the top-most argument
    of a function to the second value on the stack creating a new function.
  test:
    in: 3 5 [+] bind apply
    out: 8
}}
{ [quote] dip compose }

define bind2 : ('a 'b ('C 'a 'b -> 'D) -> ('C -> 'D))
{{
  desc:
    Partial application function, bind the top two arguments
    of a function to the second and third values on the stack
    to create a new function.
  test:
    in: 3 5 7 [+ +] bind2 apply
    out: 15
}}
{ bind bind }

define bind3 : ('a 'b 'c ('D 'a 'b 'c -> 'E) -> ('D -> 'E))
{{
  desc:
    Binds three arguments of a function to values on the stack.
}}
{ bind bind bind }

define rbind : (('B 'a -> 'C) 'a -> ('B -> 'C))
{{
  desc:
    Binds the top argument of the function in the second position on the stack
    to the value on the top of the stack.
  test:
    in: 5 [+] 3 rbind apply
    out: 8
}}
{ quote swap compose }

//=============================================================================
// Dynamically dispatched functions

define neg : (any -> any)
{{
  desc:
    Negates a values.
}}
{
  [
    int [neg_int] pair
    double [neg_dbl] pair
  ] @
  dispatch1
}

define add : (any any -> any)
{
  [
    int [add_int] pair
    double [add_dbl] pair
    byte [add_byte] pair
    bit [add_bit] pair
    string [add_str] pair
  ] @
  dispatch2
}

define sub : (any any -> any)
{
  [
    int [sub_int] pair
    double [sub_dbl] pair
    byte [sub_byte] pair
    bit [sub_bit] pair
  ] @
  dispatch2
}

define mul : (any any -> any)
{
  [
    int [mul_int] pair
    double [mul_dbl] pair
    byte [mul_byte] pair
    bit [mul_bit] pair
  ] @
  dispatch2
}

define mod : (any any -> any)
{
  [
    int [mod_int] pair
    double [mod_dbl] pair
    byte [mod_byte] pair
    bit [mod_bit] pair
  ] @
  dispatch2
}

define div : (any any -> any)
{
  [
    int [div_int] pair
    double [div_dbl] pair
    byte [div_byte] pair
    bit [div_bit] pair
  ] @
  dispatch2
}

define lt : (any any -> bool)
{
  [
    int [lt_int] pair
    double [lt_dbl] pair
    byte [lt_byte] pair
    bit [lt_bit] pair
    string [lt_str] pair
  ] @
  dispatch2
  as_bool
}

define gt : (any any -> bool)
{
  [
    int [gt_int] pair
    double [gt_dbl] pair
    byte [gt_byte] pair
    bit [gt_bit] pair
    string [lt_str] pair
  ] @
  dispatch2
  as_bool
}

define lteq : (any any -> bool)
{
  [
    int [lteq_int] pair
    double [lteq_dbl] pair
    byte [lteq_byte] pair
    bit [lteq_bit] pair
    string [lt_str] pair
  ] @
  dispatch2
  as_bool
}

define gteq : (any any -> bool)
{
  [
    int [gteq_int] pair
    double [gteq_dbl] pair
    byte [gteq_byte] pair
    bit [gteq_bit] pair
    string [lt_str] pair
  ] @
  dispatch2
  as_bool
}

//=============================================================================
// Mathematical definitions

define neq : ('a 'a -> bool)
{{
  desc:
    Pushes true if the top two values on the stack are not equal.
  test:
    in: 3 5 neq
    out: true
  test:
    in: 'a' 'a' neq
    out: false
}}
{ eq not }

define inc : (int -> int)
{{
  desc:
    Increments an integer on the top of the stack by one.
  test:
    in: 3 inc
    out: 4
}}
{ 1 add_int }

define dec : (int -> int)
{{
  desc:
    Decrements an integer on the top of the stack by one.
  test:
    in: 3 dec
    out: 2
}}
{ 1 sub_int }

define sqr : (any -> any)
{{
  desc:
    Multiplies a value by itself
  test:
    in: 3 sqr
    out: 9
}}
{ dup mul }

define frac : (int int int -> int)
{{
  desc:
    Multiplies an integer by a fraction.
    x num den -> (x * num) / den)
  test:
    in: 6 2 3 frac
    out: 4
  semantics:
    $a $b $c frac == $a $b mul_int $c div_int
}}
{ [mul_int] dip div_int }

//=============================================================================
// Mathematical symbols

define + { add }
define - { sub }
define * { mul }
define % { mod }
define / { div }
define < { lt }
define > { gt }
define <= { lteq }
define >= { gteq }
define == { eq }
define != { neq }

//=============================================================================
// Basic shuffling operators

define swapd : ('a 'b 'c -> 'b 'a 'c)
{{
  desc:
    Swaps the second and third items on the stack.
  test:
    in: 1 2 3 swapd
    out: 2 1 3
  semantics:
    $a $b $c swapd == $b $a $c
}}
{ [swap] dip }

define swapdd : ('a 'b 'c 'd -> 'b 'a 'c 'd)
{{
  desc:
    Swaps the third and fourth items on the stack.
  test:
    in: 1 2 3 4 swapdd
    out: 2 1 3 4
  semantics:
    $a $b $c $d swapd == $b $a $c $d
}}
{ [swapd] dip }

define dupd : ('a 'b -> 'a 'a 'b)
{{
  desc:
    Duplicate the second item on the stack.
  test:
    in: 1 2 dupd
    out: 1 1 2
  semantics:
    $a $b swapd == $a $a $b
}}
{ [dup] dip }

define dupdd : ('a 'b 'c -> 'a 'a 'b 'c)
{{
  desc:
    Duplicate the third item on the stack.
  test:
    in: 1 2 3 dupdd
    out: 1 1 2 3
  semantics:
    $a $b $c dupdd == $a $a $b $c
}}
{ [dupd] dip }

define popd : ('a 'b -> 'b)
{{
  desc:
    Removes the second item from the stack.
  test:
    in: 1 2 popd
    out: 2
  semantics:
    $a $b popd == $b
}}
{ [pop] dip }

define popdd : ('a 'b 'c -> 'b 'c)
{{
  desc:
    Removes the third item from the stack.
  test:
    in: 1 2 3 popdd
    out: 2 3
  semantics:
    $a $b $c popd == $b $c
}}
{ [popd] dip }

define over : ('a 'b -> 'a 'b 'a)
{{
  desc:
    Places a copy of the second item on the top of the stack.
  semantics:
    $a $b over == $b $a
}}
{ dupd swap }

define under : ('a 'b -> 'b 'a 'b)
{{
  desc:
    Places a copy of the top item on the stack under the second.
  test:
    in: 1 2 under
    out: 2 1 2
}}
{ dup swapd }

define flip : ('a 'b 'c -> 'c 'b 'a)
{{
  desc:
    Swaps the top and third item on the stack.
  test:
    in: 1 2 3 flip
    out: 3 2 1
}}
{ swapd swap swapd }

define bury : ('a 'b 'c -> 'c 'a 'b)
{{
  desc:
    Place the top item on the stack under the second item.
  test:
    in: 1 2 3 bury
    out: 3 1 2
}}
{ swap swapd }

define dig : ('a 'b 'c -> 'b 'c 'a)
{{
  desc:
    Place the third item on the stack on the top.
  test:
    in: 1 2 3 dig
    out: 2 3 1
}}
{ swapd swap }

//==============================================================================
// PeekN, DigN and BuryN functions

define pop2 : ('a 'b -> )
{{
  desc:
    Removes two item from the top of the stack.
  test:
    in: 1 2 pop2
    out:
  semantics:
    $a $b pop2 == noop
}}
{ pop pop }

define pop3 : ('a 'b 'c -> )
{{
  desc:
    Removes three item from the top of the stack.
  test:
    in: 1 2 3 pop3
    out:
  semantics:
    $a $b $c pop2 == noop
}}
{ pop pop pop }

define pop4 : ('a 'b 'c 'd -> )
{{
  desc:
    Removes four items from the top of the stack.
  test:
    in: 1 2 3 4 pop4
    out:
  semantics:
    $a $b $c $d pop4 == noop
}}
{ pop pop pop pop }

//==============================================================================
// UnderN

define under2 : ('a 'b 'c -> 'c 'a 'b 'c)
{ swap [under] dip swap }

define under3 : ('a 'b 'c 'd -> 'd 'a 'b 'c 'd)
{ swap [under2] dip swap }

define under4 : ('a 'b 'c 'd 'e -> 'e 'a 'b 'c 'd 'e)
{ swap [under3] dip swap }

define under5 : ('a 'b 'c 'd 'e 'f -> 'f 'a 'b 'c 'd 'e 'f)
{ swap [under4] dip swap }

//==============================================================================
// OverN

define over2 : ('a 'b 'c -> 'a 'b 'c 'a)
{ [over] dip swap }

define over3 : ('a 'b 'c 'd -> 'a 'b 'c 'd 'a)
{ [over2] dip swap }

define over4 : ('a 'b 'c 'd 'e -> 'a 'b 'c 'd 'e 'a)
{ [over3] dip swap }

define over5 : ('a 'b 'c 'd 'e 'f -> 'a 'b 'c 'd 'e 'f 'a)
{ [over4] dip swap }

//==============================================================================
// DigN

define dig2 : ('a 'b 'c -> 'b 'c 'a)
{ dig }

define dig3 : ('a 'b 'c 'd -> 'b 'c 'd 'a)
{ [dig2] dip swap }

define dig4 : ('a 'b 'c 'd 'e -> 'b 'c 'd 'e 'a)
{ [dig3] dip swap }

define dig5 : ('a 'b 'c 'd 'e 'f -> 'b 'c 'd 'e 'f 'a)
{ [dig4] dip swap }

define bury1 : ('a 'b -> 'b 'a)
{ swap }

//==============================================================================
// BuryN

define bury2 : ('a 'b 'c -> 'c 'a 'b)
{ bury }

define bury3 : ('a 'b 'c 'd -> 'd 'a 'b 'c)
{ swap [bury2] dip }

define bury4 : ('a 'b 'c 'd 'e -> 'e 'a 'b 'c 'd)
{ swap [bury3] dip }

define bury5 : ('a 'b 'c 'd 'e 'f -> 'f 'a 'b 'c 'd 'e)
{ swap [bury4] dip }

//==============================================================================
// DupN

define dup2 : ('a 'b -> 'a 'b 'a 'b)
{ over over }

define dup3 : ('a 'b 'c -> 'a 'b 'c 'a 'b 'c)
{ over2 over2 over2 }

define dup4 : ('a 'b 'c 'd -> 'a 'b 'c 'd 'a 'b 'c 'd)
{ over3 over3 over3 over3 }

define dup5 : ('a 'b 'c 'd 'e -> 'a 'b 'c 'd 'e 'a 'b 'c 'd 'e)
{ over4 over4 over4 over4 over4 }

//==============================================================================
// FlipN

define flip2 : ('a 'b 'c 'd -> 'd 'b 'c 'a)
{{
  desc:
    Swaps the top and fourth item on the stack.
}}
{ swap [flip] dip swap }

define flip3 : ('a 'b 'c 'd 'e -> 'e 'b 'c 'd 'a)
{{
  desc:
    Swaps the top and fifth item on the stack.
}}
{ swap [flip2] dip swap }

define flip4 : ('a 'b 'c 'd 'e 'f -> 'f 'b 'c 'd 'e 'a)
{{
  desc:
    Swaps the top and sixth item on the stack.
}}
{ swap [flip3] dip swap }

//==============================================================================
// DipN

define dip2 : ('A 'b 'c ('A -> 'D) -> 'D 'b 'c)
{{
  desc:
    Applies a function to the stack, temporarily removing the next two items.
}}
{ swap [dip] dip }

define dip3 : ('A 'b 'c 'd ('A -> 'E) -> 'E 'b 'c 'd)
{{
  desc:
    Applies a function to the stack, temporarily removing the next three items.
}}
{ swap [dip2] dip }

define dip4 : ('A 'b 'c 'd 'e ('A -> 'F) -> 'F 'b 'c 'd 'e)
{{
  desc:
    Applies a function to the stack, temporarily removing the next four items.
}}
{ swap [dip3] dip }

//=============================================================================
// Predicates and comparison functions

define eqz : (int -> int bool)  { dup 0 eq }
define neqz : (int -> int bool) { eqz not }
define gtz : (int -> int bool) { dup 0 gt_int }
define gteqz : (int -> int bool) { dup 0 gteq_int }
define ltz : (int -> int bool) { dup 0 lt_int }
define lteqz : (int -> int bool) { dup 0 lteq_int }

// Not really a predicate, but used to generate predicates
define modn : (any any -> any bool) { dupd mod 0 eq }

define even : (any -> any bool) { 2 modn }
define odd : (any -> any bool) { even not }

define is_eq : ('t 't -> 't bool)  { dupd eq }
define is_neq : ('t 't -> 't bool) { dupd neq }
define is_gt : (any any -> any bool) { dupd gt }
define is_gteq : (any any -> any bool) { dupd gteq }
define is_lt : (any any -> any bool) { dupd lt }
define is_lteq : (any any -> any bool) { dupd lteq }

define are_eq : ('t 't -> 't 't bool)  { dup2 eq }
define are_neq : ('t 't -> 't 't bool) { dup2 neq }
define are_gt : (any any -> any any bool) { dup2 gt }
define are_gteq : (any any -> any any bool) { dup2 gteq }
define are_lt : (any any -> any any bool) { dup2 lt }
define are_lteq : (any any -> any any bool) { dup2 lteq }

//=============================================================================
// Predicate generation functions

define ltf : (any -> (any -> any bool))
{ [dupd lt] bind }

define lteqf : (any -> (any -> any bool))
{ [dupd lteq] bind }

define gtf : (any -> (any -> any bool))
{ [dupd gt] bind }

define gteqf : (any -> (any -> any bool))
{ [dupd gteq] bind }

define eqf : ('a -> ('a -> 'a bool))
{ [dupd eq] bind }

define neqf : ('a -> ('a -> 'a bool))
{ [dupd neq] bind }

define modnf : (any -> (any -> any bool))
{ [modn] bind }

//=============================================================================
// Comparison predicates

define compare_lt : (any any -> any any bool)
{ dup2 lt }

define compare_lteq : (any any -> any any bool)
{ dup2 lteq  }

define compare_gt : (any any -> any any bool)
{ dup2 gt }

define compare_gteq : (any any -> any any bool)
{ dup2 lt }

// The default comparison predicate uses lteq ( <= )
define compare : (any any -> any any bool)
{ compare_lteq }

//=============================================================================
// Additional combinators

define rcompose : (('B -> 'C) ('A -> 'B) -> ('A -> 'C))
{{
  desc:
    swap then compose (or reverse compose)
  semantics:
    [$A] [$B] rcompose == [$B $A]
}}
{ swap compose }

define slip : ('A ('A -> 'B) 'c -> 'B 'c)
{{
  test:
    in: 4 [inc] 2 slip
    out: 5 2
  semantics:
    $A [$B] $c slip == $A $B $c
}}
{ swap dip }

define keep : ('A 'b ('A 'b -> 'C) -> 'C 'b)
{{
  desc:
    Applies a function to the stack, but restores the top of the stack
    afterwards to what it was before the function was applied.
  semantics:
    $A $b [$C] keep == $A $C $b
}}
{ dupd dip }

define sweep : ('A ('A 'b -> 'C) 'b -> 'C 'b)
{{
  desc:
    Swaps the top of the stack, with a function below it. Applies the function to
    the stack, and pushes the original top value back on to the stack at the end.
}}
{ swap keep }

define kapply : ('A ('A -> 'B) -> 'B ('A -> 'B))
{{
  desc:
    Applies a function to the stack, and afterwards replaces the function.
  test:
    in: 1 [inc] kapply apply
    out: 3
}}
{ dup dip }

define apply2 : ('A ('A -> 'A) -> 'A)
{{
  desc:
    Applies a function to a stack twice.
  semantics:
    $A [$B] apply2 == $A $B $B
}}
{ kapply apply }


define apply3 : ('A ('A -> 'A) -> 'A)
{{
  desc:
    Applies a function to a stack three times.
  semantics:
    $A [$B] apply3 == $A $B $B $B
}}
{ kapply apply2 }


//==============================================================================
// Looping constructions

define repeat : ('A ('A -> 'A) int -> 'A)
{{
  desc:
    Executes a loop a fixed number of times
  semantics:
    $A [$B] $c repeat == $A $c eqz [] [$B $c dec] if
}}
{
  swap            // 'A int [body]
  [dip dec] bind  // 'A int [[body] dip dec]
  [neqz] while pop
}

define whilen : ('A ('A -> 'A) ('A -> 'A bool) -> 'A)
{{
  desc:
    Executes a while loop, while a condition is not true
  semantics:
    $A [$B] [$C] whilen == $A $C not [$B [$B][$C] whilen] [] if
}}
{ [not] compose while }

define whilene : ('A list ('A list -> 'A list) -> 'A)
{{
  desc:
    Executes a function while the list on the top of the stack is not empty
  semantics:
    $A $b [$C] whilene == $A $b empty not [$C [$C] whilene] [pop] if
}}
{ [empty] whilen pop }

define whilenz : ('A int ('A int -> 'A int) -> 'A)
{{
  desc:
    Executes a function while the value on the top of the stack is not equal to zero.
  semantics:
    $A $b [$C] whilenz == $A $b neqz [$C [$C] whilenz] [pop] if
}}
{ [neqz] while pop }

define for_each : ('A list ('A any -> 'A) -> 'A)
{{
  desc:
    Executes a function with each item in the list, and consumes the list.
  semantics:
    $A $b [$C] for_each == $A $b empty not [uncons pop [$C] for_each] [pop] if }
}}
{ [dip] bind [uncons swap] rcompose whilene }

define for : ('A ('A int -> 'A) int -> 'A)
{{
  desc:
    A for loop. Behaves like repeat but an montonically increasing index value is
    passed to the loop body on each iteration, starting at 0.
}}
{ swap [dip inc] bind [dup] rcompose swap neqf 0 bury while pop }

define rfor : ('A ('A int -> 'A) int -> 'A)
{{
  desc:
    Reverse for loop. Behaves like a for loop but the index decreases from
    n down to 1.
}}
{ swap [dip dec] bind [dup] rcompose whilenz }

define print_list : ('A list ~> 'A list)
{{
  desc:
    Outputs a list to the console window
  bugs:
    The type checker requires variabe 'A to be written explicitly
}}
{ dup [writeln] for_each }

//=============================================================================
// list operators

define (
{{
  desc:
    List initializer.
}}
{ nil }

define ,
{{
  desc:
    List separator.
}}
{ cons }

define )
{{
  desc:
    List terminator.
}}
{ cons }

define ()
{{
  Desc:
    Empty list.
}}
{ nil }

define lc : (list ('a -> bool) ('b -> 'c) -> list)
{{
  desc:
    List comprehension.
}}
{ [take_while] dip map }

define consd
{{
  desc:
    Cons the second item on stack to a list in the third position.
}}
{ [cons] dip }

define swons : ('a list -> list)
{ swap cons }

define uncons2 : (list -> list any any)
{ uncons [uncons] dip }

define uncons3 : (list -> list any any any)
{ uncons [uncons2] dip }

define uncons4 : (list -> list any any any any)
{ uncons [uncons3] dip }

define unpair : (list -> any any)
{ uncons [head] dip }

define fold : ('A list 'b ('A 'b 'c -> 'A 'b) -> 'A 'b)
{ swapd gfold }

define unfold : ('A 'b ('A list 'b -> 'A list 'c 'b) ('A list 'b -> 'A list 'b bool) -> 'A list)
{{
  desc
    generates a function
}}
{ [nil bury [consd] compose] dip whilen pop }

define rev : (list -> list)
{{
  desc
    reverses a list
}}
{ nil [cons] fold }

define small : (list -> list bool)
{{
  desc
    Returns true if a list contains one element or is empty
}}
{ empty [true] [rest empty popd] if }

define split : ('A list ('A list list 'b 'b -> 'A list list 'c bool) -> 'A list list)
{{
  desc
    Splits a list into two new lists
}}
{
  nil bury nil bury
  [dup] rcompose
  [[swap [cons] dip] [cons] if] compose
  gfold
}

define cons_first : (list 'a -> list)
{{
  desc
    Appends item to first list in a pair of lists
}}
{ [unpair] dip cons pair }

define cons_second : (list 'a -> list)
{{
  desc
    Appends item to second list in a pair of lists
}}
{ [unpair] dip swap [cons] dip pair }

define move_head : (list list -> list list)
{{
  desc
    Returns the index of a value in a list or the size of the list
    if not found
}}
{ uncons swap [cons] dip }

define index_of : (list 'a -> list int)
{{
  desc
    Returns the index of a value in a list or the size of the list
    if not found
}}
{ [neq] bind count_while }

define split_at : (list int -> list list)
{{
  desc
    splits a list in two at an index, the top result contains the second half
    sand the second result contains the first half of the original list
}}
{ nil bury [move_head] swap repeat }

define dhead : (list -> list any)
{{
  desc:
    Returns the head of a list, leaving the original list on the stack.
  test:
    in: [1 2] @ dhead
    out: [1 2] @ 2
}}
{ first }

define dtail : (list -> list list)
{{
  desc:
    Returns the tail of a list, leaving the original list on the stack.
  test:
    in: [1 2 3] @ dtail
    out: [1 2 3] @ [1 2] @
}}
{ rest }

define head_eq : (list any -> list bool)
{{
  test:
    in: [1 2] @ 2 head_eq popd
    out: true

  test:
    in: [1 2] @ 1 head_eq popd
    out: false
}}
{ [dhead] dip eq }


//=============================================================================
// Infinite list generators

define range : (int int -> list)
{ [] range_gen }

define n : (int -> list)
{ 0 swap range }

define naturals : ( -> list)
{ 0 [inc] [pop true] gen }

define odds : ( -> list)
{ 1 [2 +] [pop true] gen  }

define evens : ( -> list)
{ 0 [2 +] [pop true] gen  }

define negatives : ( -> list)
{ 1 neg [dec] [pop true] gen }

define zeros : ( -> list)
{ 0 repeater }

define ones : ( -> list)
{ 1 repeater }

//==============================================================================
// Vector functions

define vec_sum : (list -> any)
{{
  desc:
    Computes the sum of elements in a vector.
}}
{ 0 [+] fold }

define vec_scale : (list any -> list)
{{
  desc:
    Multiplies all items in a vector by a scalar value.
}}
{ [*] bind map }

define vec_slide : (list any -> list)
{{
  desc:
    Adds a value to all items in a vector.
}}
{ [+] bind map }

//==============================================================================
// Hash helper functions

define hash_safe_get : (hash_list any any -> hash_list any)
{{
  desc
    Gets a value from a hash_list. If it doesn't exist then uses the default
}}
{
  [[hash_contains] keep] dip // => hash_list bool key default
  quote                      // => hash_list bool key [default]
  [[hash_get] bind] dip      // => hash_list bool [key hash_get] [default]
  if                         // => hash_list result
}

define hash_add_chain : (hash_list any 'a -> hash_list)
{{
  desc
    Adds an element as unit list to a hash_list if it doesn't exist,
    otherwise chain it to the current list item.
}}
{
  [[nil hash_safe_get] keep] dip // => hash_list curr key value
  swapd cons                     // => hash_list key list(curr, value)
  hash_set                       // => hash_list
}

define list_to_hash : (list -> hash_list)
{  hash_list [unpair swap hash_add_chain] fold }

define self_join : (list -> list)
{{
  desc:
    performs an inner self-join on a list of pairs based the first item.
}}
{ list_to_hash hash_to_list }

define join : (list list -> list)
{{
  desc:
    performs an inner join on two lists of pairs
}}
{ cat self_join }

//=============================================================================
// Deprecated operators

define qv
{ "'qv' has been replaced with 'quote'" throw }

define eval
{ "'eval' has been replaced with 'apply'" throw }

define curry
{ "'curry' has been replaced with 'bind'" throw }

define foldl
{ "'foldl' has been replaced with 'fold'" throw }

//=============================================================================
// Exception throwing and handling

define throw_if : (bool any -> )
{ [throw] bind [] if }

define assert : (bool -> )
{ "assertion failed" throw_if }

define try : ('A ('A -> 'A) -> 'A)
{{
  desc
    provides a simple default exception handler
}}
{ ["exception data: " write writeln] try_catch }

//=============================================================================
// A simple implementation of the google MapReduce algorithm
//
// In pseduo-code:
//
//   map_reduce(input fmap freduce) == input fmap flatten self_join freduce map
//
// where:
//
//     input = list(pair('input_value, 'input_key))
//     fmap = pair('input_value, 'input_key)) -> list(pair('output_value, 'output_key))
//     freduce = pair(list('output_value), 'output_key) -> pair('output_value, 'output_key)
//

define map_reduce
{ [map flatten self_join] dip map }

//========================================================================================
// Quick sort algorithm

/*
TODO: fix type bug
define qsort : (list -> list)
{{
  desc:
    This is a naive but simple implementation of a quick sort algorithm
  test:
    in: [5 4 2 1 3 2 4] @ qsort
    out: [1 2 2 3 4 4 5] @
}}
{
  // Does list have 0 or 1 elements?
  [small]
  // Base case do nothing
  []
  // Split the list using the head as a pivot
  // storing the pivot under for later use
  [uncons under [lt] bind split]
  // Append the pivot to the first list
  // then concatenate the two lists.
  [[swap cons] dip cat]
  bin_rec
}
*/