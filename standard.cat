// Cat Standard Library
// by Christopher Diggins
// http://www.cdiggins.com
// this file is public domain

//=============================================================================
// Odd ducks

define noop
{ }

define the_answer
{ 42 }

//=============================================================================
// Function manipulation operators

// quote operation aliases
define constantly : ('a -> ( -> 'a))
{ quote }

define curry : ('a ('B 'a -> 'C) -> ('B -> 'C))
{ [quote] dip compose }

define curry2 : ('a 'b ('C 'a 'b -> 'D) -> ('C -> 'D))
{ curry curry }

define curry3 : ('a 'b 'c ('D 'a 'b 'c -> 'E) -> ('D -> 'E))
{ curry curry curry }

define curry4 : ('a 'b 'c 'd ('E 'a 'b 'c 'd -> 'F) -> ('E -> 'F))
{ curry curry curry curry }

define curry5 : ('a 'b 'c 'd 'e ('F 'a 'b 'c 'd 'e -> 'G) -> ('F -> 'G))
{ curry curry curry curry curry }

define rcurry : (('B 'a -> 'C) 'a -> ('B -> 'C))
{ quote swap compose }

//=============================================================================
// Dynamically dispatched functions

define neg : ('a -> 'a)
{ [int [neg_int] pair double [neg_dbl] pair] to_list dispatch1 }

define add : ('a 'a -> 'a)
{ [int [add_int] pair double [add_dbl] pair byte [add_byte] pair bit [add_bit] pair string [add_str] pair] to_list dispatch2 }

define sub : ('a 'a -> 'a)
{ [int [sub_int] pair double [sub_dbl] pair byte [sub_byte] pair bit [sub_bit] pair] to_list dispatch2 }

define mul : ('a 'a -> 'a)
{ [int [mul_int] pair double [mul_dbl] pair byte [mul_byte] pair bit [mul_bit] pair] to_list dispatch2 }

define mod : ('a 'a -> 'a)
{ [int [mod_int] pair double [mod_dbl] pair byte [mod_byte] pair bit [mod_bit] pair] to_list dispatch2 }

define div : ('a 'a -> 'a)
{ [int [div_int] pair double [div_dbl] pair byte [div_byte] pair bit [div_bit] pair] to_list dispatch2 }

define lt : ('a 'a -> bool)
{ [int [lt_int] pair double [lt_dbl] pair byte [lt_byte] pair bit [lt_bit] pair string [lt_str] pair] to_list dispatch2 }

define gt : ('a 'a -> bool)
{ [int [gt_int] pair double [gt_dbl] pair byte [gt_byte] pair bit [gt_bit] pair string [lt_str] pair] to_list dispatch2 }

define lteq : ('a 'a -> bool)
{ [int [lteq_int] pair double [lteq_dbl] pair byte [lteq_byte] pair bit [lteq_bit] pair string [lt_str] pair] to_list dispatch2 }

define gteq : ('a 'a -> bool)
{ [int [gteq_int] pair double [gteq_dbl] pair byte [gteq_byte] pair bit [gteq_bit] pair string [lt_str] pair] to_list dispatch2 }

//=============================================================================
// Mathematical definitions

// Not equals
define neq
{ eq not }

// Increment a value
define inc : (int -> int) { 1 add }

// Decrement a value
define dec : (int -> int) { 1 sub }

// Multiply a value by itself
define sqr : ('a 'a -> 'a) { dup mul }

// Treats top two values as a fraction 6 2 3 frac = 6 * (2 / 3)
define frac : (int int int -> int) { [mul] dip div }

//=============================================================================
// Mathematical symbols

define + { add }
define - { sub }
define * { mul }
define % { mod }
define / { div }
define < { lt }
define > { gt }
define <= { lteq }
define >= { gteq }
define == { eq }
define != { neq }

//=============================================================================
// Basic shuffling operators

define swapd : ('a 'b 'c -> 'b 'a 'c)
{ [swap] dip }

define swapdd : ('a 'b 'c 'd -> 'b 'a 'c 'd)
{ [swapd] dip }

define dupd : ('a 'b -> 'a 'a 'b)
{ [dup] dip }

define dupdd : ('a 'b 'c -> 'a 'a 'b 'c)
{ [dupd] dip }

define popd : ('a 'b -> 'b)
{ [pop] dip }

define popdd : ('a 'b 'c -> 'b 'c)
{ [popd] dip }

define pop2 : ('a 'b -> )
{ pop pop }

define pop3 : ('a 'b 'c -> )
{ pop pop pop pop }

define pop4 : ('a 'b 'c 'd -> )
{ pop pop pop pop }

define nip : ('a 'b -> 'b)
{ popd }

define over : ('a 'b -> 'a 'b 'a)
{ dupd swap }

define under : ('a 'b -> 'b 'a 'b)
{ dup swapd }

define flip : ('a 'b 'c -> 'c 'b 'a)
{ swapd swap swapd }

define bury : ('a 'b 'c -> 'c 'a 'b)
{ swap swapd }

define dig : ('a 'b 'c -> 'b 'c 'a)
{ swapd swap }

define peek : ('a 'b 'c -> 'a 'b 'c 'a)
{ dupdd dig }

define poke : ('a 'b 'c -> 'c 'b)
{ popdd swap }

//==============================================================================
// PeekN, DigN and BuryN functions

define peek1 : ('a 'b -> 'a 'b 'a)
{ dupd swap }

// The same as ordinary "peek"
define peek2 : ('a 'b 'c -> 'a 'b 'c 'a)
{ [peek1] dip swap }

define peek3 : ('a 'b 'c 'd -> 'a 'b 'c 'd 'a)
{ [peek2] dip swap }

define peek4 : ('a 'b 'c 'd 'e -> 'a 'b 'c 'd 'e 'a)
{ [peek3] dip swap }

define peek5 : ('a 'b 'c 'd 'e 'f -> 'a 'b 'c 'd 'e 'f 'a)
{ [peek4] dip swap }

define dig1 : ('a 'b -> 'b 'a)
{ swap }

// The same as ordinary "dig"
define dig2 : ('a 'b 'c -> 'b 'c 'a)
{ [dig1] dip swap }

define dig3 : ('a 'b 'c 'd -> 'b 'c 'd 'a)
{ [dig2] dip swap }

define dig4 : ('a 'b 'c 'd 'e -> 'b 'c 'd 'e 'a)
{ [dig3] dip swap }

define dig5 : ('a 'b 'c 'd 'e 'f -> 'b 'c 'd 'e 'f 'a)
{ [dig4] dip swap }

define bury1 : ('a 'b -> 'b 'a)
{ swap }

// The same as ordinary "bury"
define bury2 : ('a 'b 'c -> 'c 'a 'b)
{ swap [bury1] dip }

define bury3 : ('a 'b 'c 'd -> 'd 'a 'b 'c)
{ swap [bury2] dip }

define bury4 : ('a 'b 'c 'd 'e -> 'e 'a 'b 'c 'd)
{ swap [bury3] dip }

define bury5 : ('a 'b 'c 'd 'e 'f -> 'f 'a 'b 'c 'd 'e)
{ swap [bury4] dip }

//==============================================================================
// DupN

define dup2 : ('a 'b -> 'a 'b 'a 'b)
{ peek1 peek1 }

define dup3 : ('a 'b 'c -> 'a 'b 'c 'a 'b 'c)
{ peek2 peek2 peek2 }

define dup4 : ('a 'b 'c 'd -> 'a 'b 'c 'd 'a 'b 'c 'd)
{ peek3 peek3 peek3 peek3 }

define dup5 : ('a 'b 'c 'd 'e -> 'a 'b 'c 'd 'e 'a 'b 'c 'd 'e)
{ peek4 peek4 peek4 peek4 peek4 }

//=============================================================================
// Predicates and comparison functions

define neq : (var var -> bool) { eq not }
define eqz : ('a -> 'a bool)  { dup 0 eq }
define neqz : ('a -> 'a bool) { eqz not }
define gtz : ('a -> 'a bool) { dup 0 gt }
define gteqz : ('a -> 'a bool) { dup 0 gteq }
define ltz : ('a -> 'a bool) { dup 0 lt }
define lteqz : ('a -> 'a bool) { dup 0 lteq }

// Not really a predicate, but used to generate predicate
define modn : (int -> int bool) { dupd mod 0 eq }

define even : (int -> int bool) { 2 modn }
define odd : (int -> int bool) { dup inc mod 0 eq }

define is_eq : ('a 'a -> 'a bool)  { dupd eq }
define is_neq : ('a 'a -> 'a bool) { dupd neg }
define is_gt : ('a 'a -> 'a bool) { dupd gt }
define is_gteq : ('a 'a -> 'a bool) { dupd gteq }
define is_lt : ('a 'a -> 'a bool) { dupd lt }
define is_lteq : ('a 'a -> 'a bool) { dupd lteq }

//=============================================================================
// Predicate generation functions

define ltf : ('a -> ('a -> 'a bool))
{ [dupd lt] curry }

define lteqf : ('a -> ('a -> 'a bool))
{ [dupd lteq] curry }

define gtf : ('a -> ('a -> 'a bool))
{ [dupd gt] curry }

define gteqf : ('a -> ('a -> 'a bool))
{ [dupd gteq] curry }

define eqf : ('a -> ('a -> 'a bool))
{ [dupd eq] curry }

define neqf : ('a -> ('a -> 'a bool))
{ [dupd neq] curry }

define modnf : ('a -> ('a -> 'a bool))
{ [dupd modn] curry }

//=============================================================================
// Comparison predicates

define compare_lt : ('a 'a -> 'a 'a bool)
{ dup2 lt }

define compare_lteq : ('a 'a -> 'a 'a bool)
{ dup2 lteq  }

define compare_gt : ('a 'a -> 'a 'a bool)
{ dup2 gt }

define compare_gteq : ('a 'a -> 'a 'a bool)
{ dup2 lt }

// The default comparison predicate uses lteq ( <= )
define compare : ('a 'a -> 'a 'a bool)
{ compare_lteq }

//=============================================================================
// Additional combinators

// swap then compose (or reverse compose)
define rcompose : (('B -> 'C) ('A -> 'B) -> ('A -> 'C))
{ swap compose }

// Sometime called "slip"
define swip : ('A ('A -> 'B) 'c -> 'B 'c)
{ swap dip }

// Sometimes called "sip"
define keep : ('A 'b ('A 'b -> 'C) -> 'C 'b)
{ dupd dip }

define sweep : ('A ('A 'b -> 'C) 'b -> 'C 'b)
{ swap keep }

define dip2 : ('A 'b 'c ('A -> 'D) -> 'D 'b 'c)
{ swap [dip] dip }

define dip3 : ('A 'b 'c 'd ('A -> 'E) -> 'E 'b 'c 'd)
{ swap [dip2] dip }

define dip4 : ('A 'b 'c 'd 'e ('A -> 'F) -> 'F 'b 'c 'd 'e)
{ swap [dip3] dip }

//==============================================================================
// Looping constructions

// execute a loop a number of times
define repeat : ('A ('A -> 'A) int -> 'A)
{
  swap            // 'A int [body]
  [dip dec] curry // 'A int [[body] dip dec]
  [neqz] while pop
}

// while condition is not true
define whilen
{ [not] compose while }

// while top list is not empty
define whilene
{ [empty] whilen }

// while top value is not equal to zero
define whilenz
{ [neqz] while }

define for_each : ('A list ('A 'b -> 'A) -> 'A)
{ [dip] curry [uncons swap] rcompose whilene pop }

// like repeat but an index is passed at each iteration (0..n-1)
define for : ('A ('A int -> 'A) int -> 'A)
{ swap [dip inc] curry [dup] rcompose swap neqf 0 bury while pop }

// a for loop but the index decreases from n down to 1
define rfor : ('A ('A int -> 'A) int -> 'A)
{ swap [dip dec] curry [dup] rcompose whilenz pop }

// Output
define print_list : (list ~> list)
{ [writeln] for_each }

//=============================================================================
// list operators

define (
{ nil }

define ,
{ cons }

define )
{ cons }

define ()
{ nil }

// list comprehension
define lc : (list ('a -> bool) ('a -> 'b) -> list)
{ [take_while] dip map }

define consd
{ [cons] dip }

define swons : (var list -> list)
{ swap cons }

define uncons2 : (list -> list var var)
{ uncons [uncons] dip }

define uncons3 : (list -> list var var var)
{ uncons [uncons2] dip }

define uncons4 : (list -> list var var var var)
{ uncons [uncons3] dip }

define unpair : (list -> var var)
{ uncons [head] dip }

define fold : (list 'a ('a 'b -> 'a) -> 'a)
{ swapd gfold }

define unfold : ('a ('a -> 'a 'a) ('a -> 'a bool) -> list)
{ [nil bury [consd] compose] dip whilen }

// Returns true iff any value satisfies the condition
define any : (list ('a -> bool) -> bool)
{ dupd [or] compose false swap fold }

// Returns true iff all values satisfy the condition
define all : (list ('a -> bool) -> bool)
{ dupd [and] compose true swap fold }

// reverses a list
define rev : (list -> list)
{ nil [cons] fold }

// Returns true if a list contains one element or is empty
define small : (list -> list bool)
{ empty [true] [rest empty nip] if }

// Splits a list into two new lists
define split : (list ('a -> bool) -> list list)
{
  nil bury nil bury
  [dup] rcompose
  [[swap [cons] dip] [cons] if] compose
  gfold
}

// Appends item to first list in a pair of lists
define cons_first : (list var -> list)
{ [unpair] dip cons pair }

// Appends item to second list in a pair of lists
define cons_second : (list var -> list)
{ [unpair] dip swap [cons] dip pair }

// Removes head from first list and gives it to the next one
define move_head : (list list -> list lsit)
{ uncons swap cons }

// Returns the index of a value in a list or the size of the list
// if not found
define index_of : (list var -> list int)
{ [neq] curry count_while }

// splits a list in two at an index, the top result contains the second half
// and the second result contains the frist half of the original list
define split_at : (list int -> list list)
{ nil bury [move_head] swap repeat }

//=============================================================================
// Infinite list generators

define range : (int int -> list)
{ [] range_gen }

define n : (int -> list)
{ 0 swap range }

define naturals : ( -> list)
{ 0 [inc] [pop true] gen }

define odds : ( -> list)
{ 1 [2 +] [pop true] gen  }

define evens : ( -> list)
{ 0 [2 +] [pop true] gen  }

define negatives : ( -> list)
{ 1 neg [dec] [pop true] gen }

define zeros : ( -> list)
{ 0 repeater }

define ones : ( -> list)
{ 1 repeater }

//==============================================================================
// Vector functions

define sum : (list -> var)
{ 0 [+] fold }

define scale_int_vector : (list int -> list)
{ [mul_int] curry map }

define translate_int_vector : (list int -> list)
{ [add_int] curry map }

define scale_dbl_vector : (list int -> list)
{ [mul_dbl] curry map }

define translate_dbl_vector : (list int -> list)
{ [add_dbl] curry map }

//==============================================================================
// Hash helper functions

// Gets a value from a hash_list. If it doesn't exist then uses the default
define hash_safe_get : (hash_list key=var default=var -> hash_list var)
{
  [[hash_contains] keep] dip // => hash_list bool key default
  quote                      // => hash_list bool key [default]
  [[hash_get] curry] dip     // => hash_list bool [key hash_get] [default]
  if                         // => hash_list result
}

// Adds an element as unit list to a hash_list if it doesn't exist,
// otherwise chain it to the current list item.
define hash_add_chain : (hash_list key=var value=var -> hash_list)
{
  [[nil hash_safe_get] keep] dip // => hash_list curr key value
  swapd cons                     // => hash_list key list(curr, value)
  hash_set                       // => hash_list
}

define list_to_hash : (list -> hash_list)
{  hash_list [unpair swap hash_add_chain] fold }

// performs an inner self-join on a list of pairs based the first item.
define self_join : (list -> list)
{ list_to_hash hash_to_list }

// performs an inner join on two lists of pairs
define join : (list list -> list)
{ cat self_join }

//=============================================================================
// Deprecated operators

define qv
{ "'qv' has been replaced with 'quote'" throw }

define eval
{ "'eval' has been replaced with 'apply'" throw }

define foldl
{ "'foldl' has been replaced with 'fold'" throw }

//=============================================================================
// Exception throwing and handling

define throw_if : (bool var -> )
{ [throw] curry [] if }

define assert : (bool -> )
{ "assertion failed" throw_if }

// a default handler for simple procedures
define try : ('A ('A -> 'A) -> 'A)
{ ["exception data: " write writeln] try_catch }

//=============================================================================
// A simple implementation of the google MapReduce algorithm
//
// In pseduo-code:
//
//   map_reduce(input fmap freduce) == input fmap flatten self_join freduce map
//
// where:
//
//     input = list(pair('input_value, 'input_key))
//     fmap = pair('input_value, 'input_key)) -> list(pair('output_value, 'output_key))
//     freduce = pair(list('output_value), 'output_key) -> pair('output_value, 'output_key)
//

define map_reduce { [map flatten self_join] dip map }

//========================================================================================
// Quick sort algorithm

define qsort : (list -> list)
{
  // Does to_list have 0 or 1 elements?
  [small]
  // Base case do nothing
  []
  // Split the to_list using the head as a pivot
  // storing the pivot under for later use
  [uncons under [lt] curry split]
  // Append the pivot to the first to_list
  // then concatenate the two lists.
  [[swap cons] dip cat]
  bin_rec
}

//========================================================================================
// Classical combinators, optimized definitions

define y
{ dup quote [y] compose swap apply }

// \a.aa
define m
{ dup apply }

//=========================================================================================
// Combinatory logic combinators, classical definitions

// \abc.ac(bc)
define s
{ peek swap [curry] dip2 apply }

// \ab.a
define k
{ popd apply }

// \a.a
define i
{ [k] [k] s }

// \ab.b(ab)
define o
{ [i] s }

// \abc.a(bc)
define b
{ [k] [[s] k] s }

// \abcd.ab(cd)
define d
{ [b] b }

// \ab.b(ab)
define o
{ [i] s }

// \abc.acb
define c
{ [[k] k] [[s] [b] b] s }

// \ab.ba
define t
{ [i] c }

// \abcde.ab(cde)
define e
{ [b] [b] b b }

// \abc.cba
define f
{ [t] [e] [t] [t] e }

// \ab.a(bb)
define l
{ [m] [b] c }

// \abc.bca
define r
{ [t] [b] b }

// \ab.b(aab)
define u
{ [o] l }

// \abc.cab
define v
{ [t] [c] b }

// \ab.abb
define w
{ [r] [m] b c }

// \ab.b
define ki
{ [i] k }