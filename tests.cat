// Cat Standard Tests
// by Christopher Diggins
// http://www.cdiggins.com
// this file is public domain
//
// These tests are ordered in terms of increasing sophistiction of a Cat implementation
// simpler implementations would not be expected to support the whole range.

define test : (( -> bool) -> )
{
  dup apply [pop] [throw] if
}

// This is designed to test a minimalist Cat implementation
define test0
{
  // if tests
  [true [true] [false] if] test
  [false [false] [true] if] test
  [false [true] [false] if not] test
  [true [false] [true] if not] test

  // boolean tests
  [true] test
  [true not not] test
  [false not] test
  [false not not not] test

  // and tests
  [true true and] test
  [true false and not] test
  [false true and not] test
  [false false and not] test

  // or tests
  [true true or] test
  [true false or] test
  [false true or] test
  [false false or not] test

  // basic equality tests
  [0 0 eq] test
  [1 1 eq] test
  [0 1 eq not] test
  [1 0 eq not] test

  // basic comparison tests
  [0 0 lteq] test
  [0 1 lteq] test
  [1 0 lteq not] test
  [1 1 lteq] test

  // swap tests
  [1 2 pop 1 eq] test
  [1 2 swap pop 2 eq] test
  [1 2 swap swap pop 1 eq] test

  // dip tests
  [1 1 2 [eq] dip pop] test
  [1 2 1 [neq] dip pop] test
  [2 [1] dip pop 1 eq] test
  [1 [2] dip pop 2 eq] test
  [2 1 [pop] dip 1 eq] test
  [1 2 [pop] dip 2 eq] test
  [1 2 3 [swap] dip pop pop 2 eq] test
  [1 2 3 [pop] dip pop 1 eq] test
  [1 2 3 [pop pop] dip 3 eq] test
  [1 2 3 [[pop] dip pop] dip 3 eq] test
  [1 2 3 [[pop] dip] dip swap pop 3 eq] test
}

define _43210
{ 0 [1 add] [5 lt] gen }

define _3210
{ 0 4 [id] range_gen }

define _234
{ [2 3 4] to_list }

define _01234
{ [0 1 2 3 4] to_list }

define _23
{ 2 3 pair }

define _012
{ nil 0 cons 1 cons 2 cons }

define _01
{ 0 1 pair }

define _0
{ 0 unit }

define _0123
{ _01 _23 cat }

define test1
{
  // comparison tests
  [0 0 lteq] test
  [0 0 gteq] test
  [0 1 lt] test
  [0 1 lteq] test
  [0 1 gt not] test
  [0 1 gteq not] test
  [1 0 lt not] test
  [1 0 lteq not] test
  [1 0 gt] test
  [1 0 gteq] test
  [1 1 lt not] test
  [1 1 lteq] test
  [1 1 gt not] test
  [1 1 gteq] test

  // core equality tests
  [nil nil eq] test
  [_0 _0 eq] test
  [_01 _01 eq] test
  [_012 _012 eq] test
  [_0123 _0123 eq] test

  // to_list generator
  [[0] to_list _0 eq] test
  [[0 1] to_list _01 eq] test
  [[0 1 2] to_list _012 eq] test
  [[0 1 2 3] to_list _0123 eq] test

  // cons
  [nil 1 cons 1 unit eq] test

  // head items
  [_0 head 0 eq] test
  [_01 head 1 eq] test
  [_012 head 2 eq] test
  [_0123 head 3 eq] test
  [_01234 head 4 eq] test
  [_43210 head 0 eq] test
  [_3210 head 0 eq] test
  [_234 head 4 eq] test
  [_23 head 3 eq] test

  // first=head
  [_0 first swap head eq] test
  [_01 first swap head eq] test
  [_012 first swap head eq] test
  [_0123 first swap head eq] test
  [_01234 first swap head eq] test
  [_43210 first swap head eq] test
  [_3210 first swap head eq] test
  [_234 first swap head eq] test
  [_23 first swap head eq] test

  // last items
  [_0 last swap pop 0 eq] test
  [_01 last swap pop 0 eq] test
  [_012 last swap pop 0 eq] test
  [_0123 last swap pop 0 eq] test
  [_01234 last swap pop 0 eq] test
  [_43210 last swap pop 4 eq] test
  [_3210 last swap pop 3 eq] test
  [_234 last swap pop 2 eq] test
  [_23 last swap pop 2 eq] test

  // to_list to non-list comparison
  [nil 0 neq] test
  [0 nil neq] test

  // empty
  [nil empty swap pop] test
  [_0123 empty swap pop not] test
  [_012 empty swap pop not] test
  [_01 empty swap pop not] test
  [_0 empty swap pop not] test

  // count
  [_0123 count swap pop 4 eq] test
  [_012 count swap pop 3 eq] test
  [_01 count swap pop 2 eq] test
  [_0 count swap pop 1 eq] test
  [nil count swap pop 0 eq] test

  // cat
  [_01 _23 cat _0123 eq] test
  [0 unit 1 unit cat _01 eq] test

  // nth test
  [_0123 0 nth swap pop 3 eq] test
  [_0123 1 nth swap pop 2 eq] test
  [_0123 2 nth swap pop 1 eq] test
  [_0123 3 nth swap pop 0 eq] test
  [_012 0 nth swap pop 2 eq] test
  [_012 1 nth swap pop 1 eq] test
  [_012 2 nth swap pop 0 eq] test
  [_01 0 nth swap pop 1 eq] test
  [_01 1 nth swap pop 0 eq] test
  [_0 0 nth swap pop 0 eq] test

  // map test
  [_0123 [2 *] map [0 2 4 6] to_list eq] test
  [_012 [2 *] map [0 2 4] to_list eq] test
  [_01 [2 *] map [0 2] to_list eq] test
  [_0 [2 *] map [0] to_list eq] test
  [nil [2 *] map nil eq] test
  [_0123 [1 +] map [1 2 3 4] to_list eq] test
  [_012 [1 +] map [1 2 3] to_list eq] test
  [_01 [1 +] map [1 2] to_list eq] test
  [_0 [1 +] map [1] to_list eq] test
  [nil [1 +] map nil eq] test

  // filter
  [_0123 [1 gt] filter [2 3] to_list eq] test
  [_012 [1 gt] filter [2] to_list eq] test
  [_01 [1 gt] filter nil eq] test
  [_0 [1 gt] filter nil eq] test
  [nil [1 gt] filter nil eq] test
  [_0123 [2 lt] filter _01 eq] test
  [_012 [2 lt] filter _01 eq] test
  [_01 [2 lt] filter _01 eq] test
  [_0 [2 lt] filter _0 eq] test
  [nil [2 lt] filter nil eq] test
  [_0123 [2 mod 0 eq] filter [0 2] to_list eq] test
  [_012 [2 mod 0 eq] filter [0 2] to_list eq] test
  [_01 [2 mod 0 eq] filter _0 eq] test
  [_0 [2 mod 0 eq] filter _0 eq] test
  [nil [2 mod 0 eq] filter nil eq] test

  // fold
  [_0123 0 [+] fold 6 eq] test
  [_012 0 [+] fold 3 eq] test
  [_01 0 [+] fold 1 eq] test
  [_0 0 [+] fold 0 eq] test
  [nil 0 [+] fold 0 eq] test
  [_0123 nil [cons] fold [3 2 1 0] to_list eq] test

  // take
  [_01234 0 take nil eq] test
  [_0123 0 take nil eq] test
  [_012 0 take nil eq] test
  [_01 0 take nil eq] test
  [_0 0 take nil eq] test
  [nil 0 take nil eq] test
  [_01234 1 take 4 unit eq] test
  [_0123 1 take 3 unit eq] test
  [_012 1 take 2 unit eq] test
  [_01 1 take 1 unit eq] test
  [_0 1 take _0 eq] test
  [nil 1 take nil eq] test
  [_01234 5 take _01234 eq] test
  [_0123 5 take _0123 eq] test
  [_012 5 take _012 eq] test
  [_01 5 take _01 eq] test
  [_0 5 take _0 eq] test
  [nil 5 take nil eq] test

  // drop
  [_01234 0 drop _01234 eq] test
  [_0123 0 drop _0123 eq] test
  [_012 0 drop _012 eq] test
  [_01 0 drop _01 eq] test
  [_0 0 drop _0 eq] test
  [nil 0 drop nil eq] test
  [_01234 5 drop nil eq] test
  [_0123 5 drop nil eq] test
  [_012 5 drop nil eq] test
  [_01 5 drop nil eq] test
  [_0 5 drop nil eq] test
  [nil 5 drop nil eq] test
  [_01234 1 drop _0123 eq] test
  [_0123 1 drop _012 eq] test
  [_012 1 drop _01 eq] test
  [_01 1 drop _0 eq] test
  [_0 1 drop nil eq] test
  [nil 1 drop nil eq] test

  // tail
  [_01234 tail _0123 eq] test
  [_0123 tail _012 eq] test
  [_012 tail _01 eq] test
  [_01 tail _0 eq] test
  [_0 tail nil eq] test
  [nil tail nil eq] test

  // take while
  [[1 0 3 2 1 0] to_list [2 lt] take_while [1 0] to_list eq] test

  // drop while
  [[1 0 3 2 1 0] to_list [2 lt] drop_while [1 0 3 2] to_list eq] test
}

define test_strings
{
  (
    (("The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog"), 1),
    (("I", "am", "very", "lazy"), 2),
    (("I", "hope", "this", "is", "over", "quick"), 3),
    (("I", "have", "high", "hopes", "for", "the", "lazy", "dog"), 4)
  )
}

define test_pair_list : ( -> list)
{
  ((1, "a"),(2, "b"),(3, "a"),(4, "c"),(5, "b"),(6, "a"))
}

define test_joined_list : ( -> list)
{
  (
    ((4), "c"),
    ((5, 2), "b"),
    ((6, 3, 1), "a")
  )
}

define test_m
{ unpair pop [1 swap pair] map }

define test_r
{ unpair [sum] dip pair }

define test_map_reduce
{ test_strings [test_m] [test_r] map_reduce print_list }

define test2
{
  [() nil eq] test

  // flatten tests
  [(()) flatten nil eq] test
  [((0)) flatten (0) eq] test
  [((0),(1)) flatten (0,1) eq] test
  [((0),((1))) flatten (0,(1)) eq] test
  [((0,1),(2,3),(4),nil,(5,6,7)) flatten (0,1,2,3,4,5,6,7) eq] test

  // pair tests
  [1 2 pair [1 2] to_list eq] test
  [1 2 pair (1, 2) eq] test
  [[1 2] to_list (1, 2) eq] test
  [(1, 2) unpair pair (1, 2) eq] test
  [(1, (2,3)) unpair swap pop (2, 3) eq] test

  // Hash to_list tests
  [hash_list hash_to_list nil eq] test
  [hash_list "a" 1 hash_add hash_to_list ((1, "a")) eq] test
  [hash_list 1 hash_contains swap pop not] test
  [hash_list "hello" hash_contains swap pop not] test
  [hash_list "a" 1 hash_add "a" hash_contains swap pop] test
  [hash_list "a" 1 hash_add "b" hash_contains swap pop not] test
  [hash_list 24 "a" hash_add 24 hash_get swap pop "a" eq] test
  [hash_list "a" 42 hash_add "a" hash_get swap pop 42 eq] test
  [test_pair_list self_join test_joined_list eq] test

  // pair to_list tests
  [nil nil pair ((),()) eq] test
  [nil nil pair 1 cons_first (nil,(1)) eq] test
  [nil nil pair 1 cons_second ((1),nil) eq] test

  // gfold test (gets the 8th fibonnaci number)
  [0 1 6 n [pop dup2 + dig pop] gfold + 21 eq] test

  // split tests
  [(1, 2) [2 <] split pair ((1),(2)) eq] test
  [(1, 2) [2 >] split pair ((),(2, 1)) eq] test
  [(1, 2) [1 >] split pair ((2),(1)) eq] test
  [(1, 2) [pop true] split pair ((2, 1),()) eq] test
  [(1, 2) [pop false] split pair ((),(2, 1)) eq] test
  [() [true] split pair ((),()) eq] test

  // small tests
  [() small nip] test
  [(0) small nip] test
  [(0,1) small nip not] test
}

define test3
{
  [0 0 range nil eq] test
  [0 1 range (0) eq] test
  [0 2 range (1, 0) eq] test
  [0 3 range (2, 1, 0) eq] test
  [0 4 range (3, 2, 1, 0) eq] test
  [0 5 range (4, 3, 2, 1, 0) eq] test
  [1 1 range (1) eq] test
  [1 2 range (2, 1) eq] test
  [1 3 range (3, 2, 1) eq] test
  [1 4 range (4, 3, 2, 1) eq] test
  [1 5 range (5, 4, 3, 2, 1) eq] test
  [2 1 range (2) eq] test
  [2 2 range (3, 2) eq] test
  [2 3 range (4, 3, 2) eq] test
  [2 4 range (5, 4, 3, 2) eq] test
  [2 5 range (6, 5, 4, 3, 2) eq] test
}

define test4
{
  [5 n head 0 eq] test
  [5 n tail 1 4 range eq] test
  [5 n count swap pop 5 eq] test
  [5 n [pop true] count_while swap pop 5 eq] test
  [5 n empty swap pop not] test
  [5 n (4, 3, 2, 1, 0) eq] test
  [5 n [4 3 2 1 0] to_list eq] test
  [5 n 0 5 range eq] test
  [5 n 0 5 [inc dec] range_gen eq] test
  [5 n 0 [inc] [5 <] gen eq] test
  [5 n naturals 5 take eq] test
  [5 n naturals [5 <] take_while eq] test
  [5 n [3 <] take_while 3 n eq] test
  [5 n 3 take 3 n eq] test
  [5 n naturals [5 <] [] lc eq] test
}

// floating point comparisons
define test5
{
  [1.0 2.0 <=] test
  [1.0 2.0 <=] test
  [2.0 1.0 >=] test
  [2.0 1.0 >=] test
  [1.0 1.0 + 1.0 1.0 + eq] test
}

// Test numerical representations
define test6
{
  [0b1 1 eq] test
  [0b0 0 eq] test
  [0b1001 9 eq] test
  [0b10000000000 1024 eq] test
  [0x1 1 eq] test
  [0x0 0 eq] test
  [0xff 255 eq] test
  [0x100 256 eq] test
  [0b100000000 256 eq] test
  [255 str "255" eq] test
  [255 hex_str "ff" eq] test
  [255 bin_str "11111111" eq] test
  [0x234 to_byte 0x34 to_byte eq] test
}

define test7
{
  [4 [eqz] [pop 1] [dec dup] [+] bin_rec 16 eq] test

  // test qsort
  [() qsort () eq] test
  [(1) qsort (1) eq] test
  [(4,2,3,1) qsort (1,2,3,4) eq] test
  [(1,2,3,4) qsort (1,2,3,4) eq] test
  [(4,3,2,1) qsort (1,2,3,4) eq] test
  [(1,1,1,1) qsort (1,1,1,1) eq] test
  [(2,4,3,2,1,1,3,4) qsort (1,1,2,2,3,3,4,4) eq] test

  // test byte blocks
  [0 byte_block count nip 0 eq] test
  [1 byte_block count nip 1 eq] test
  [99 byte_block count nip 99 eq] test
  [42 byte_block 13 nth nip 0 to_byte eq] test
  [42 byte_block 25 to_byte 13 set_at 13 nth nip 25 to_byte eq] test
}

define test_io
{
  temp_file dup
  file_writer
  2 byte_block
  0xf1 to_byte 0 set_at
  0xa9 to_byte 1 set_at
  write_bytes
  close_stream
  file_reader
  2 read_bytes
  [close_stream] dip
}

define test_types
{
  [] #t
  [id] #t
  [id id] #t
  [id id id] #t
  [dup] #t
  [dup dup] #t
  [dup dup dup] #t
  [pop] #t
  [pop pop] #t
  [pop pop pop] #t
  [swap] #t
  [swap swap] #t
  [swap swap swap] #t
  [swap pop] #t
  [pop swap] #t
  [swap dup] #t
  [dup swap] #t
  [swap pop dup] #t
  [swap dup pop] #t
  [dup swap pop] #t
  [pop swap dup] #t
  [pop dup swap] #t
  [dup pop swap] #t
  [apply] #t
  [apply apply] #t
  [apply apply apply] #t
  [dup dip] #t
  [dup apply] #t
  [dip dip] #t
  [dip dup] #t
}

define run_tests
{
  test0
  test1
  test2
  test3
  test4
  test5
  test6
  test7
  "tests completed successfully" writeln
}

//////////////////////////////////////////////////////////////////////////////////////////
// Fix-point combinator tests

define y_fact_step
{ over 0 eq [pop2 1] [[dup dec] dip apply *] if }

define y_fact
{ [y_fact_step] y }

define y_test
{
  "expect 120 " writeln
  5 y_fact writeln
}

define m_fact_step
{ over 0 eq [pop2 1] [[dup dec] dip m *] if }

define m_fact
{ [m_fact_step] m }

define m_test
{
  "expect 120 " writeln
  5 m_fact writeln
}

define m_while : ('A ('A -> 'A) ('A -> 'A bool) -> 'A)
{
  [dip swap] curry swap // [[$B] dip swap] $A
  [dip m] curry         // [[$B] dip swap] [[$A] dip Y]
  quote compose            // [[$B] dip swap [[$A] dip Y]]
  [[pop] if] compose    // [[$B] dip swap [[$A] dip Y] [pop] if]
  m
}

//////////////////////////////////////////////////////////////////////////////////////////

define incf { [i 1 +] compose }
define x2f { [i 2 *] compose }
define sqrf { [i dup *] compose }
define halvef { [i 2 /] compose }

define test_combinator
{
  write dup write ", " write to_list writeln
}

define cl_tests
{
  [[1] i]         "1 " test_combinator
  [[2] [1] k]     "1 " test_combinator
  [[2] [1] ki]    "2 " test_combinator
  [[1] m]         "[1] 1 " test_combinator
  [[2] [1] o]     "[[2] 1] 2 " test_combinator
  [[2] [1] t]     "[2] 1 " test_combinator
  [[2] [1] w]     "[[2] 2] 1 " test_combinator
  [[3] [2] [1] b] "[[3] 2] 1 " test_combinator
  [[3] [2] [1] c] "[[2] 3] 1 " test_combinator
  [[3] [2] [1] r] "[[1] 3] 2 " test_combinator
  [[3] [2] [1] v] "[[2] 1] 3 " test_combinator
  [[3] [2] [1] f] "[[1] 2] 3 " test_combinator
}

//////////////////////////////////////////////////////////////////////////////////////////
// Type tests

define type_test
{
  swap writeln
  "expected : " write
  [writeln] dip
  "actual   : " write
  type_of
  writeln
}

define test_types
{
  "( -> int int)" [42 dup] type_test
  "(a -> a a)" [dup dup] type_test
  "(a b -> b a)" [swap] type_test
  "(a b -> b a)" [quote dip] type_test
  "(int -> int)" [[1 add_int] apply] type_test
  "(a (a B -> C) -> (B -> C)" [curry] type_test
  "(a (a B -> C) -> (B -> C)" [[quote] dip compose] type_test
  "((A -> B) (C -> A) -> (C -> B)" [swap compose] type_test
  "(int -> int)" [true [] [1 +] if] type_test
}

//////////////////////////////////////////////////////////////////////////////////////////
// Macro Tests

define macro_test
{
  "expected " write
  [write] dip
  dup
  ", source " write
  write
  #m
  ", result " write
  writeln
}

define test_macros
{
  [] [noop]  macro_test
  [] [id]  macro_test
  [[]] [[id]] macro_test
  [] [swap swap]  macro_test
  [] [dup pop]  macro_test
  [] [not not]  macro_test
  [] [pair unpair]  macro_test
  [] [cons uncons]  macro_test
  [dup] [dup swap]  macro_test
  [] [swap quote dip] macro_test
  [] [dup swap pop]  macro_test
  [2 1] [1 2 swap]  macro_test
  [2 1] [1 2 swap swap swap] macro_test
  [true] [false true and not]  macro_test
  [[42]] [42 quote] macro_test
  [42] [[42] apply] macro_test
  [42] [42 quote apply] macro_test
  [[1 2]] [[1] [2] compose] macro_test
  [2] [1 2 nip] macro_test
  [2] [1 2 popd] macro_test
  [nil] [nil [2 mul_int] map] macro_test
  [nil] [nil [3 lt_int] filter] macro_test
  [42] [nil 42 [add_int] fold] macro_test
  [1 1 2] [1 2 dupd] macro_test
  [2 1 3] [1 2 3 swapd] macro_test
  [2 3 1] [1 2 3 dig] macro_test
  [3 1 2] [1 2 3 bury] macro_test
  [3 2 3] [1 2 3 poke] macro_test
  [1 2 3 1] [1 2 3 peek] macro_test
  [swap] [swap and] macro_test
  [[1 2 3 4] to_list] [[1 2] to_list [3 4] to_list cat] macro_test
  [[1 +] [2 *] compose map] [[1 +] map [2 *] map] macro_test
  [[1 + 2 *] compose map] [[1 +] [2 *] compose map] macro_test
  [[1 2] dip] [[1] dip [2] dip] macro_test
}

//////////////////////////////////////////////////////////////////////////////////////////
// Partial Evaluation Tests


//////////////////////////////////////////////////////////////////////////////////////////
// More Optimziation Tests

define test_o
{
  [i] #i #m #m #m #m #m #m #m #m [42] swap apply
}

